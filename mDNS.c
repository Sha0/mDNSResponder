// ***************************************************************************// mDNS.c// This file defines all of mDNS, including// mDNS Service Discovery, mDNS Responder, and mDNS Searcher.//// This code is completely 100% portable C. It does not include any external header files// from outside the mDNS project -- all the types it expects to find are defined right here.//// The previous point is very important: This file does not include any external// header files. It will complile on *any* platform that has a C compiler, without// making *any* assumptions about availability of so-called "standard" C functions,// routines, or types (which may or may not be present on any given platform).// ***************************************************************************// If you see "local" before a function name, it means the function is not callable outside this file#define local static// If you see "export" before a function name, it means the function is exported for use by clients#define export// These are common types with the standard meanings you'd expecttypedef unsigned char  Boolean;typedef   signed char  SInt8;typedef unsigned char  UInt8;typedef   signed short SInt16;typedef unsigned short UInt16;typedef   signed long  SInt32;typedef unsigned long  UInt32;// These types are for opaque two- and four-byte identifiers.// The "NotAnInteger" fields of the unions allow the value to be conveniently passed around in a register// for the sake of efficiency, but don't forget -- just because it is in a register doesn't mean it is an// integer. Operations like add, multiply, increment, decrement, etc., are undefined for opaque identifiers.typedef union  { unsigned char b[2]; UInt16 NotAnInteger; } Opaque16;typedef union  { unsigned char b[4]; UInt32 NotAnInteger; } Opaque32;typedef Opaque16 IPPort;		// An IP port is a two-byte opaque identifier (not an integer)typedef Opaque32 IPAddr;		// An IP address is a four-byte opaque identifier (not an integer)#define NULL 0Lenum { false = 0, true = 1 };#include "mDNSPlatformFunctions.h"		// Defines the interface required of the supporting layer below// ***************************************************************************#pragma mark - DNS Protocol Constantstypedef enum	{	kDNSFlag0_QR_Mask     = 0x80,		// Query or response?	kDNSFlag0_QR_Query    = 0x00,	kDNSFlag0_QR_Response = 0x80,		kDNSFlag0_OP_Mask     = 0x78,		// Operation type	kDNSFlag0_OP_Query    = 0x00,	kDNSFlag0_OP_Iquery   = 0x08,	kDNSFlag0_OP_Status   = 0x10,	kDNSFlag0_OP_Unused3  = 0x18,	kDNSFlag0_OP_Notify   = 0x20,	kDNSFlag0_OP_Update   = 0x28,		kDNSFlag0_QROP_Mask   = kDNSFlag0_QR_Mask | kDNSFlag0_OP_Mask,		kDNSFlag0_AA          = 0x04,		// Authoritative Answer?	kDNSFlag0_TC          = 0x02,		// Truncated?	kDNSFlag0_RD          = 0x01,		// Recursion Desired?	kDNSFlag1_RA          = 0x80,		// Recursion Available?		kDNSFlag1_Zero        = 0x40,		// Reserved; must be zero	kDNSFlag1_AD          = 0x20,		// Authentic Data [RFC 2535]	kDNSFlag1_CD          = 0x10,		// Checking Disabled [RFC 2535]	kDNSFlag1_RC          = 0x0F,		// Response code	kDNSFlag1_RC_NoErr    = 0x00,	kDNSFlag1_RC_FmtErr   = 0x01,	kDNSFlag1_RC_SrvErr   = 0x02,	kDNSFlag1_RC_NXDomain = 0x03,	kDNSFlag1_RC_NotImpl  = 0x04,	kDNSFlag1_RC_Refused  = 0x05,	kDNSFlag1_RC_YXDomain = 0x06,	kDNSFlag1_RC_YXRRSet  = 0x07,	kDNSFlag1_RC_NXRRSet  = 0x08,	kDNSFlag1_RC_NotAuth  = 0x09,	kDNSFlag1_RC_NotZone  = 0x0A	} DNS_Flags;// ***************************************************************************#pragma mark - Program Constantsstatic const ResourceRecord zeroRR;static const IPPort zeroIPPort;static const IPAddr zeroIPAddr;// ***************************************************************************#pragma mark -#pragma mark - Domain Name Utility Functions// Returns length of a domain name INCLUDING the byte for the final null label// i.e. for the root label "." it returns one// For the FQDN "com." it returns 5 (length, three data bytes, final zero)export UInt32 DomainNameLength(const domainname *const name)	{	const UInt8 *src = name->c;	while (*src)		{		if (*src > MAX_DOMAIN_LABEL) return(MAX_DOMAIN_NAME+1);		src += 1 + *src;		if (src - name->c >= MAX_DOMAIN_NAME) return(MAX_DOMAIN_NAME+1);		}	return(src - name->c + 1);	}export void AppendDomainLabelToName(domainname *const name, const domainlabel *const label)	{	int i;	UInt8 *ptr = name->c + DomainNameLength(name) - 1;	const UInt8 *const lim = name->c + MAX_DOMAIN_NAME;	if (ptr + 1 + label->c[0] + 1 >= lim) return;	for (i=0; i<=label->c[0]; i++) *ptr++ = label->c[i];	*ptr++ = 0;										// Put the null root label on the end	}// AppendStringLabelToName appends a single label to an existing (possibly empty) domainname.// The C string contains the label as-is, with no escaping, etc.// Any dots in the name are literal dots, not label separatorsexport void AppendStringLabelToName(domainname *const name, const char *cstr)	{	UInt8 *lengthbyte;	UInt8 *ptr = name->c + DomainNameLength(name) - 1;	const UInt8 *lim = name->c + MAX_DOMAIN_NAME - 1;	if (lim > ptr + MAX_DOMAIN_LABEL + 1)		lim = ptr + MAX_DOMAIN_LABEL + 1;	lengthbyte = ptr++;	while (*cstr && ptr < lim) *ptr++ = *cstr++;	*lengthbyte = ptr - lengthbyte - 1;	*ptr++ = 0;										// Put the null root label on the end	}// AppendStringNameToName appends zero or more labels to an existing (possibly empty) domainname.// The C string contains the labels separated by dots, but otherwise as-is, with no escaping, etc.export void AppendStringNameToName(domainname *const name, const char *cstr)	{	UInt8 *ptr = name->c + DomainNameLength(name) - 1;			// Find end of current name	const UInt8 *const lim = name->c + MAX_DOMAIN_NAME - 1;		// Find limit of how much we can add	while (*cstr)		{		UInt8 *const lengthbyte = ptr++;		const UInt8 *const lim2 = ptr + MAX_DOMAIN_LABEL;		const UInt8 *const lim3 = (lim < lim2) ? lim : lim2;		while (*cstr && *cstr != '.' && ptr < lim3) *ptr++ = *cstr++;		*lengthbyte = ptr - lengthbyte - 1;		if (*cstr == '.') cstr++;		}		*ptr++ = 0;										// Put the null root label on the end	}//#define IsThreeDigit(X) (IsDigit((X)[1]) && IsDigit((X)[2]) && IsDigit((X)[3]))//#define ValidEscape(X) (X)[0] == '\\' && ((X)[1] == '\\' || (X)[1] == '\\' || IsThreeDigit(X))#define DIGIT(X) ((X) >= '0' && (X) <= '9')export void ConvertCStringToDomainLabel(const char *src, domainlabel *label)	{	UInt8       *      ptr   = label->c + 1;					// Where we're putting it	const UInt8 *const limit = ptr + MAX_DOMAIN_LABEL;			// The maximum we can put	while (*src && ptr < limit)									// While we have characters in the label...		{		UInt8 c = *src++;										// Read the character		if (c == '\\')											// If escape character, check next character			{			if (*src == '\\' || *src == '.')					// If a second escape, or a dot,				c = *src++;										// just use the second character			else if (DIGIT(src[0]) && DIGIT(src[1]) && DIGIT(src[2]))				{												// else, if three decimal digits,				UInt16 v0 = src[0] - '0';						// then interpret as three-digit decimal				UInt16 v1 = src[1] - '0';				UInt16 v2 = src[2] - '0';				UInt16 val = v0 * 100 + v1 * 10 + v2;				if (val <= 255) { c = val; src += 3; }			// If valid value, use it				}			}		*ptr++ = c;												// Write the character		}	label->c[0] = ptr - label->c - 1;	}//local UInt8 *convertCstringtodomainname_withescape(const char *const cstr, domainname *name, int esc)export UInt8 *ConvertCStringToDomainName(const char *const cstr, domainname *name)	{	const UInt8 *src         = (const UInt8 *)cstr;					// C string we're reading	UInt8       *ptr         = name->c;								// Where we're putting it	const UInt8 *const limit = ptr + MAX_DOMAIN_NAME;				// The maximum we can put	while (*src && ptr < limit)										// While more characters, and space to put them...		{		UInt8 *lengthbyte = ptr++;									// Record where the length is going to go		while (*src && *src != '.' && ptr < limit)					// While we have characters in the label...			{			UInt8 c = *src++;										// Read the character			if (c == '\\')											// If escape character, check next character				{				if (*src == '\\' || *src == '.')					// If a second escape, or a dot,					c = *src++;										// just use the second character				else if (DIGIT(src[0]) && DIGIT(src[1]) && DIGIT(src[2]))					{												// else, if three decimal digits,					UInt16 v0 = src[0] - '0';						// then interpret as three-digit decimal					UInt16 v1 = src[1] - '0';					UInt16 v2 = src[2] - '0';					UInt16 val = v0 * 100 + v1 * 10 + v2;					if (val <= 255) { c = val; src += 3; }			// If valid value, use it					}				}			*ptr++ = c;												// Write the character			}		if (*src) src++;											// Skip over the trailing dot (if present)		if (ptr - lengthbyte - 1 > MAX_DOMAIN_LABEL) return(NULL);	// If illegal label, abort		*lengthbyte = ptr - lengthbyte - 1;		}	if (ptr < limit)												// If we didn't run out of space		{		*ptr++ = 0;													// Put the final root label		return(ptr);												// and return		}	return(NULL);	}//#define convertCstringtodomainname(C,D)        convertCstringtodomainname_withescape((C), (D), -1)//#define convertescapedCstringtodomainname(C,D) convertCstringtodomainname_withescape((C), (D), '\\')export char *ConvertDomainLabelToCString_withescape(const domainlabel *const label, char *ptr, UInt8 esc)	{	const UInt8 *      src = label->c;							// Domain label we're reading	const UInt8        len = *src++;							// Read length of this (non-null) label	const UInt8 *const end = src + len;							// Work out where the label ends	if (len > MAX_DOMAIN_LABEL) return(NULL);					// If illegal label, abort	while (src < end)											// While we have characters in the label		{		UInt8 c = *src++;		if (esc)			{			if (c == '.')										// If character is a dot,				*ptr++ = esc;									// Output escape character			else if (c <= ' ')									// If non-printing ascii,				{												// Output decimal escape sequence				*ptr++ = esc;				*ptr++ = '0' + c / 100;				*ptr++ = '0' + (c % 100) / 10;				c      = '0' + (c % 10);				}			}		*ptr++ = c;												// Copy the character		}	*ptr = 0;													// Null-terminate the string	return(ptr);												// and return	}// Note, to guarantee that there will be no possible overrun, cstr must be at least 1005 bytes// The longest legal domain name is 255 bytes, in the form of three 64-byte labels, one 62-byte label,// and the null root label.// If every label character has to be escaped as a four-byte escape sequence, the maximum textual// ascii display of this is 63*4 + 63*4 + 63*4 + 61*4 = 1000 label characters,// plus four dots and the null at the end of the C string = 1005export char *ConvertDomainNameToCString_withescape(const domainname *const name, char *ptr, UInt8 esc)	{	const UInt8 *src         = name->c;								// Domain name we're reading	const UInt8 *const max   = name->c + MAX_DOMAIN_NAME;			// Maximum that's valid		if (*src == 0) *ptr++ = '.';									// Special case: For root, just write a dot	while (*src)													// While more characters in the domain name		{		if (src + 1 + *src >= max) return(NULL);		ptr = ConvertDomainLabelToCString_withescape((const domainlabel *)src, ptr, esc);		if (!ptr) return(NULL);		src += 1 + *src;		*ptr++ = '.';												// Write the dot after the label		}	*ptr++ = 0;														// Null-terminate the string	return(ptr);													// and return	}export UInt8 *ConstructServiceName(domainname *const fqdn, const domainlabel *const name, const domainname *const type, const domainname *const domain)	{	int i, len;	UInt8 *dst = fqdn->c;	UInt8 *max = fqdn->c + MAX_DOMAIN_NAME;	const UInt8 *src;	if (name)		{		src = name->c;									// Put the service name into the domain name		len = *src;		if (len >= 0x40) { debugf("constructServiceName: service name too long"); return(0); }		for (i=0; i<=len; i++) *dst++ = *src++;		}		src = type->c;										// Put the service type into the domain name	len = *src;	if (len == 0 || len >= 0x40)  { debugf("constructServiceName: Invalid service name"); return(0); }	if (dst + 1 + len + 1 >= max) { debugf("constructServiceName: service type too long"); return(0); }	for (i=0; i<=len; i++) *dst++ = *src++;	len = *src;	if (len == 0 || len >= 0x40)  { debugf("constructServiceName: Invalid service name"); return(0); }	if (dst + 1 + len + 1 >= max) { debugf("constructServiceName: service type too long"); return(0); }	for (i=0; i<=len; i++) *dst++ = *src++;		if (*src) { debugf("constructServiceName: Service type must have only two labels"); return(0); }	src = domain->c;									// Put the service domain into the domain name	while (*src)		{		len = *src;		if (dst + 1 + len + 1 >= max)			{ debugf("constructServiceName: service domain too long"); return(0); }		for (i=0; i<=len; i++) *dst++ = *src++;		}		*dst++ = 0;		// Put the null root label on the end	return(dst);	}export Boolean DeconstructServiceName(const domainname *const fqdn, domainlabel *const name, domainname *const type, domainname *const domain)	{	int i, len;	const UInt8 *src = fqdn->c;	const UInt8 *max = fqdn->c + MAX_DOMAIN_NAME;	UInt8 *dst;		dst = name->c;										// Extract the service name from the domain name	len = *src;	if (len >= 0x40)		{ debugf("deconstructServiceName: service name too long"); return(false); }	for (i=0; i<=len; i++) *dst++ = *src++;		dst = type->c;										// Extract the service type from the domain name	len = *src;	if (src + 1 + len + 1 >= max)		{ debugf("deconstructServiceName: service type too long"); return(false); }	for (i=0; i<=len; i++) *dst++ = *src++;	len = *src;	if (src + 1 + len + 1 >= max)		{ debugf("deconstructServiceName: service type too long"); return(false); }	for (i=0; i<=len; i++) *dst++ = *src++;	*dst++ = 0;		// Put the null root label on the end of the service type	dst = domain->c;									// Extract the service domain from the domain name	while (*src)		{		len = *src;		if (src + 1 + len + 1 >= max)			{ debugf("deconstructServiceName: service domain too long"); return(0); }		for (i=0; i<=len; i++) *dst++ = *src++;		}	*dst++ = 0;		// Put the null root label on the end		return(true);	}local Boolean sameDomainLabel(const UInt8 *a, const UInt8 *b)	{	int i;	const int len = *a++;	if (len > MAX_DOMAIN_LABEL)		{ debugf("Malformed label (too long)"); return(false); }	if (len != *b++) return(false);	for (i=0; i<len; i++)		{		UInt8 ac = *a++;		UInt8 bc = *b++;		if (ac >= 'A' && ac <= 'Z') ac += 'a' - 'A';		if (bc >= 'A' && bc <= 'Z') bc += 'a' - 'A';		if (ac != bc) return(false);		}	return(true);	}export Boolean sameDomainName(const domainname *const d1, const domainname *const d2)	{	const UInt8 *      a   = d1->c;	const UInt8 *      b   = d2->c;	const UInt8 *const max = d1->c + MAX_DOMAIN_NAME;			// Maximum that's valid	while (*a || *b)		{		if (a + 1 + *a >= max)			{ debugf("Malformed domain name (more than 255 characters)"); return(false); }		if (!sameDomainLabel(a, b)) return(false);		a += 1 + *a;		b += 1 + *b;		}		return(true);	}// Check for matching initial substring// e.g. matchPartialDomainName("_afp._tcp.", "_afp._tcp.apple.com.") returns truelocal Boolean matchPartialDomainName(const domainname *const subs, const domainname *const name)	{	const UInt8 *      a   = subs->c;	const UInt8 *      b   = name->c;	const UInt8 *const max = subs->c + MAX_DOMAIN_NAME;			// Maximum that's valid	while (*a)		{		if (a + 1 + *a >= max)			{ debugf("Malformed domain name (more than 255 characters)"); return(false); }		if (!sameDomainLabel(a, b)) return(false);		a += 1 + *a;		b += 1 + *b;		}		return(true);	}// ***************************************************************************#pragma mark -#pragma mark - DNS Message Creation Functionslocal void InitializeDNSMessage(DNSMessageHeader *h, Opaque16 id, Opaque16 flags)	{	h->id             = id;	h->flags          = flags;	h->numQuestions   = 0;	h->numAnswers     = 0;	h->numAuthorities = 0;	h->numAdditionals = 0;	}local const UInt8 *FindCompressionPointer(const UInt8 *const base, const UInt8 *const end, const UInt8 *const domname)	{	const UInt8 *result = end - *domname - 1;#if 0	char buffer[256];	ConvertDomainNameToCString((domainname *)domname, buffer);	debugf("FindCompressionPointer searching for %s", buffer);#endif	if (*domname == 0) return(NULL);	// There's no point trying to match just the root label		// This loop examines each possible starting position in packet, starting end of the packet and working backwards	while (result >= base)		{		// If the length byte and first character of the label match, then check further to see		// if this location in the packet will yield a useful name compression pointer.		if (result[0] == domname[0] && result[1] == domname[1])			{			const UInt8 *name = domname;			const UInt8 *targ = result;			while (targ + *name < end)				{				// First see if this label matches				int i;				const UInt8 *pointertarget;				for (i=0; i <= *name; i++) if (targ[i] != name[i]) break;				if (i <= *name) break;							// If label did not match, bail out				targ += 1 + *name;								// Else, did match, so advance target pointer				name += 1 + *name;								// and proceed to check next label				if (*name == 0 && *targ == 0) return(result);	// If no more labels, we found a match!				if (*name == 0) break;							// If no more labels to match, we failed, so bail out				// The label matched, so now follow the pointer (if appropriate) and then see if the next label matches				if (targ[0] < 0x40) continue;					// If length value, continue to check next label				if (targ[0] < 0xC0) break;						// If 40-BF, not valid				if (targ+1 >= end) break;						// Second byte not present!				pointertarget = base + (((UInt16)(targ[0] & 0x3F)) << 8) + targ[1];				if (targ < pointertarget) break;				// Pointertarget must point *backwards* in the packet				if (pointertarget[0] >= 0x40) break;			// Pointertarget must point to a valid length byte				targ = pointertarget;				}			}		result--;	// We failed to match at this search position, so back up the tentative result pointer and try again		}	return(NULL);	}// Put a string of dot-separated labels as length-prefixed labels// domainname is a fully-qualified name (i.e. assumed to be ending in a dot, even if it doesn't)// msg points to the message we're building (pass NULL if we don't want to use compression pointers)// end points to the end of the message so far// ptr points to where we want to put the name// limit points to one byte past the end of the buffer that we must not overrun// domainname is the name to putlocal UInt8 *putDomainNameAsLabels(const DNSMessage *const msg, UInt8 *ptr, const UInt8 *const limit, const domainname *const name)	{	const UInt8 *const base        = (const UInt8 *const)msg;	const UInt8 *      np          = name->c;	const UInt8 *const max         = name->c + MAX_DOMAIN_NAME;	// Maximum that's valid	const UInt8 *      pointer     = NULL;	const UInt8 *const searchlimit = ptr;	while (*np && ptr < limit-1)		// While we've got characters in the name, and space to write them in the message...		{		if (np + 1 + *np >= max)			{ debugf("Malformed domain name (more than 255 characters)"); return(NULL); }		if (base) pointer = FindCompressionPointer(base, searchlimit, np);		if (pointer)					// Use a compression pointer if we can			{			UInt16 offset = pointer - base;			*ptr++ = 0xC0 | (offset >> 8);			*ptr++ = offset & 0xFF;			return(ptr);			}		else							// Else copy one label and try again			{			int i;			UInt8 len = *np++;			if (ptr + 1 + len >= limit) return(NULL);			*ptr++ = len;			for (i=0; i<len; i++) *ptr++ = *np++;			}		}	if (ptr < limit)												// If we didn't run out of space		{		*ptr++ = 0;													// Put the final root label		return(ptr);												// and return		}	return(NULL);	}local UInt8 *putRData(const DNSMessage *const msg, UInt8 *ptr, const UInt8 *const limit, const UInt16 rrtype, UInt32 rdlength, const RData *const rdata)	{	switch (rrtype)		{		case kDNSType_A:	*ptr++ = rdata->ip.b[0];							*ptr++ = rdata->ip.b[1];							*ptr++ = rdata->ip.b[2];							*ptr++ = rdata->ip.b[3]; break;		case kDNSType_CNAME:// Same as PTR		case kDNSType_PTR:	ptr = putDomainNameAsLabels(msg, ptr, limit, &rdata->name);		break;		case kDNSType_TXT:  mDNSPlatformMemCopy(rdata->data, ptr, rdlength); ptr += rdlength; break;		case kDNSType_SRV:	*ptr++ = (rdata->srv.priority >> 8) & 0xFF;							*ptr++ = (rdata->srv.priority     ) & 0xFF;							*ptr++ = (rdata->srv.weight   >> 8) & 0xFF;							*ptr++ = (rdata->srv.weight       ) & 0xFF;							*ptr++ = (rdata->srv.port.b[0]);							*ptr++ = (rdata->srv.port.b[1]);							ptr = putDomainNameAsLabels(msg, ptr, limit, &rdata->srv.target);							break;		default:			debugf("Error! Don't know how to write resource type %d", rrtype);							break;		}	return(ptr);	}// Put a domain name, type, class, ttl, length, and type-specific data// domainname is a fully-qualified name (i.e. assumed to be ending in a dot, even if it doesn't)local UInt8 *putResourceRecord(DNSMessage *const msg, UInt8 *ptr, const UInt8 *const limit, UInt16 *count,								const ResourceRecord *rr)	{	UInt8 *endofrdata;	UInt32 actualLength;	if (rr->RecordType == kDNSRecordTypeConflict)		{		debugf("putResourceRecord ERROR! Attempt to put a conflicting ResourceRecord");		return(ptr);		}	ptr = putDomainNameAsLabels(msg, ptr, limit, &rr->name);	if (!ptr || ptr+4 >= limit) return(NULL);			// If we're out-of-space, return NULL	*ptr++ = rr->rrtype  >> 8;	*ptr++ = rr->rrtype  & 0xFF;	*ptr++ = rr->rrclass >> 8;	*ptr++ = rr->rrclass & 0xFF;		if (ptr + 6 + rr->rdlength >= limit) return(NULL);	// If we're out-of-space, return NULL	ptr[0] = (rr->rroriginalttl >> 24) & 0xFF;	ptr[1] = (rr->rroriginalttl >> 16) & 0xFF;	ptr[2] = (rr->rroriginalttl >>  8) & 0xFF;	ptr[3] = (rr->rroriginalttl      ) & 0xFF;	endofrdata = putRData(msg, ptr+6, limit, rr->rrtype, rr->rdlength, &rr->rdata);	if (!endofrdata) { debugf("Ran out of space in putResourceRecord!"); return(NULL); }	// Go back and fill in the actual number of data bytes we wrote	// (actualLength could be less than rdlength if we implement domain name compression)	actualLength = endofrdata - ptr - 6;	ptr[4] = actualLength >> 8;	ptr[5] = actualLength & 0xFF;	(*count)++;	return(endofrdata);	}local UInt8 *putQuestion(DNSMessage *const msg, UInt8 *ptr, const UInt8 *const limit,							const domainname *const name, UInt16 rrtype, UInt16 rrclass)	{	ptr = putDomainNameAsLabels(msg, ptr, limit, name);	if (!ptr || ptr+4 >= limit) return(NULL);			// If we're out-of-space, return NULL	*ptr++ = rrtype  >> 8;	*ptr++ = rrtype  & 0xFF;	*ptr++ = rrclass >> 8;	*ptr++ = rrclass & 0xFF;	msg->h.numQuestions++;	return(ptr);	}// ***************************************************************************#pragma mark -#pragma mark - DNS Message Parsing Functions// Routine to fetch an FQDN from the DNS message, following compression pointers if necessary.local const UInt8 *getDomainName(const DNSMessage *const msg, const UInt8 *ptr, const UInt8 *const end, domainname *const name)	{	const UInt8 *nextbyte = NULL;	UInt8       *np = name->c;							// Name pointer	const UInt8 *const limit = np + MAX_DOMAIN_NAME;	// Limit so we don't overrun buffer	while (ptr < end && np < limit)				// Read sequence of labels out of QNAME field		{		const UInt8 len = *ptr++;				// Read length of this label		if (len == 0) break;					// If length is zero, that means this name is complete		switch (len & 0xC0)			{			int i;			UInt16 offset;			case 0x00:	if (ptr + len >= end)							{ debugf("Malformed domain name (overruns packet end)"); return(NULL); }						if (np + 1 + len >= limit)							{ debugf("Malformed domain name (more than 255 characters)"); return(NULL); }						*np++ = len;						for (i=0; i<len; i++) *np++ = *ptr++;						break;			case 0x40:	debugf("Extended EDNS0 label types not supported"); break;			case 0x80:	debugf("Illegal label length in domain name"); break;			case 0xC0:	offset = (((UInt16)(len & 0x3F)) << 8) | *ptr++;						if (!nextbyte) nextbyte = ptr;	// Record where we got to before we started following pointers						ptr = (UInt8 *)msg + offset;						if (*ptr & 0xC0) { debugf("Compression pointer must point to real label"); return(NULL); }						break;			}		}		if (np < limit) *np++ = 0;				// Put the null root label on the end of the name	else { debugf("Domain name too long!"); return(NULL); }	if (nextbyte) return(nextbyte);	else return(ptr);	}local const UInt8 *getResourceRecord(const DNSMessage *msg, const UInt8 *ptr, const UInt8 *end, const IPAddr interface, const SInt32 timenow, UInt8 RecordType, ResourceRecord *rr)	{	UInt32 pktrdlength;	rr->next             = NULL;	rr->additional       = NULL;	rr->collision        = NULL;	rr->RecordType       = RecordType;	rr->PacketCount      = 0;	rr->SendPriority     = 0;	rr->NextSendTime     = 0;	rr->NextSendInterval = 0;	rr->TimeRcvd         = timenow;	rr->LastUsed         = timenow - 0x3FFFFFFF;	rr->interface        = interface;	ptr = getDomainName(msg, ptr, end, &rr->name);	if (!ptr) return(NULL);	if (ptr + 10 > end) { debugf("Malformed DNS resource record -- no type/class/ttl/len!"); return(NULL); }		rr->rrtype         = (UInt16)ptr[0] <<  8 | ptr[1];	rr->rrclass        = (UInt16)ptr[2] <<  8 | ptr[3];	rr->rroriginalttl  = (UInt32)ptr[4] << 24 | (UInt32)ptr[5] << 16 | (UInt32)ptr[6] << 8 | ptr[7];	rr->rrremainingttl = 0;	rr->rdlength       = (UInt16)ptr[8] <<  8 | ptr[9];	pktrdlength        = rr->rdlength;	ptr += 10;	if (ptr + pktrdlength > end) { debugf("Malformed DNS resource record rdata !"); return(NULL); }		if (rr->rroriginalttl > 0x7FFFFFFF / mDNSPlatformOneSecond)		rr->rroriginalttl = 0x7FFFFFFF / mDNSPlatformOneSecond;	switch (rr->rrtype)		{		case kDNSType_A:	rr->rdata.ip.b[0] = ptr[0];							rr->rdata.ip.b[1] = ptr[1];							rr->rdata.ip.b[2] = ptr[2];							rr->rdata.ip.b[3] = ptr[3]; break;		case kDNSType_CNAME:// Same as PTR		case kDNSType_PTR:	getDomainName(msg, ptr, end, &rr->rdata.name);							rr->rdlength = DomainNameLength(&rr->rdata.name);							//debugf("%##s PTR %##s rdlen %d", rr->name.c, rr->rdata.name.c, rr->rdlength);							break;		case kDNSType_TXT:  mDNSPlatformMemCopy(ptr, rr->rdata.data, pktrdlength); break;		case kDNSType_SRV:	rr->rdata.srv.priority = (UInt16)ptr[0] <<  8 | ptr[1];							rr->rdata.srv.weight   = (UInt16)ptr[2] <<  8 | ptr[3];							rr->rdata.srv.port.b[0] = ptr[4];							rr->rdata.srv.port.b[1] = ptr[5];							getDomainName(msg, ptr+6, end, &rr->rdata.srv.target);							rr->rdlength = 6 + DomainNameLength(&rr->rdata.srv.target);							//debugf("%##s SRV %##s rdlen %d", rr->name.c, rr->rdata.srv.target.c, rr->rdlength);							break;		default:			debugf("Warning! Don't know how to read resource type %d", rr->rrtype);							// Note: Just because we don't understand the record type, that doesn't							// mean we fail. The DNS protocol specifies rdlength, so we can							// safely skip over unknown records and ignore them.							// We also grab a binary copy of the rdata anyway, since the caller							// might know how to interpret it even if we don't.							mDNSPlatformMemCopy(ptr, rr->rdata.data, pktrdlength);							break;		}	return(ptr + pktrdlength);	}local const UInt8 *getQuestion(const DNSMessage *msg, const UInt8 *ptr, const UInt8 *end, const IPAddr interface, DNSQuestion *question)	{	question->interface = interface;	ptr = getDomainName(msg, ptr, end, &question->name);	if (ptr+4 > end) { debugf("Malformed DNS question section -- no query type and class!"); return(NULL); }		question->rrtype  = (UInt16)ptr[0] << 8 | ptr[1];			// Get type	question->rrclass = (UInt16)ptr[2] << 8 | ptr[3];			// and class	return(ptr+4);	}local const UInt8 *locateDNSanswers(const DNSMessage *const response, const UInt8 *const end)	{	// Skip past the question section	const UInt8 *ptr = response->data;	DNSQuestion q;	int i;	for (i = 0; i < response->h.numQuestions && ptr; i++) ptr = getQuestion(response, ptr, end, zeroIPAddr, &q);	return(ptr);	}// ***************************************************************************#pragma mark -#pragma mark - Resource Record Utility Functions#define ResourceRecordAdditionalValid(RR) ((RR)->additional == NULL || ((RR)->additional->PacketCount == 0))#define ResourceRecordIsValidForAnswer(RR) ((RR)->RecordType == kDNSRecordTypeShared && ResourceRecordAdditionalValid(RR)  || \                                            (RR)->RecordType == kDNSRecordTypeUnique && (RR)->PacketCount == 0             || \                                            (RR)->RecordType == kDNSRecordTypeKnownUnique                                  || \                                            (RR)->RecordType == kDNSRecordTypePacketAnswer                                 || \                                            (RR)->RecordType == kDNSRecordTypePacketAdditional                              )local Boolean ResourceRecordAnswersQuestion(const ResourceRecord *const rr, const DNSQuestion *const q)	{	if (!ResourceRecordIsValidForAnswer(rr)) return(false);		if (rr->interface.NotAnInteger && q->interface.NotAnInteger && rr->interface.NotAnInteger != q->interface.NotAnInteger) return(false);	// RR type CNAME matches any query type. QTYPE ANY matches any RR type. QCLASS ANY matches any RR class.	if (rr->rrtype != kDNSType_CNAME && rr->rrtype  != q->rrtype  && q->rrtype  != kDNSQType_ANY ) return(false);	if (                                rr->rrclass != q->rrclass && q->rrclass != kDNSQClass_ANY) return(false);	return(sameDomainName(&rr->name, &q->name));	}// ResourceRecord *pktrr is the ResourceRecord from the response packet we've witnessed on the network// ResourceRecord *rr is our ResourceRecord// Returns 0 if there is no conflict// Returns +1 if there was a conflict and we won// Returns -1 if there was a conflict and we lost and have to renamelocal int ResourceRecordConflict(ResourceRecord *pkt, ResourceRecord *our)	{	UInt8 pktdata[256], *pktptr = pktdata, *pktend;	UInt8 ourdata[256], *ourptr = ourdata, *ourend;	if (!pkt) { debugf("ResourceRecordConflict ERROR: pkt is NULL"); return(+1); }	if (!our) { debugf("ResourceRecordConflict ERROR: our is NULL"); return(+1); }	if (our->RecordType == kDNSRecordTypeConflict) return(0);		// If this record already dead, not a conflict	if (our->RecordType == kDNSRecordTypeShared) return(0);			// If this is a shared record, not a conflict	if (pkt->rrtype  != our->rrtype ) return(0);					// If type different, not a conflict	if (pkt->rrclass != our->rrclass) return(0);					// If class different, not a conflict	if (!sameDomainName(&pkt->name, &our->name)) return(0);			// If name different, not a conflict	pktend = putRData(NULL, pktdata, pktdata + sizeof(pktdata), pkt->rrtype, pkt->rdlength, &pkt->rdata);	ourend = putRData(NULL, ourdata, ourdata + sizeof(ourdata), our->rrtype, our->rdlength, &our->rdata);	while (pktptr < pktend && ourptr < ourend && *pktptr == *ourptr) { pktptr++; ourptr++; }	if (pktptr >= pktend && ourptr >= ourend) return(0);			// If data identical, not a conflict	if (pktptr >= pktend) return(-1);								// Packet data is substring; We lost	if (ourptr >= ourend) return(+1);								// Our data is substring; We won	if (*pktptr < *ourptr) return(-1);								// Packet data is numerically lower; We lost	if (*pktptr > *ourptr) return(+1);								// Our data is numerically lower; We won		debugf("ResourceRecordConflict: How did we get here?");	return(-1);	}local Boolean SameRData(const UInt16 rrtype, const UInt32 rdlength, const RData *const r1, const RData *const r2)	{	switch(rrtype)		{		case kDNSType_CNAME:// Same as PTR		case kDNSType_PTR:	return(sameDomainName(&r1->name, &r2->name));		case kDNSType_SRV:	return( r1->srv.priority          == r2->srv.priority          &&									r1->srv.weight            == r2->srv.weight            &&									r1->srv.port.NotAnInteger == r2->srv.port.NotAnInteger &&									sameDomainName(&r1->srv.target, &r2->srv.target));		default:			return(mDNSPlatformMemSame(r1, r2, rdlength));		}	}// SameResourceRecord returns true if two resources records have the same name, type, class,// and identical rdata, but not necessarily the same TTLlocal Boolean SameResourceRecord(const ResourceRecord *const r1, const ResourceRecord *const r2)	{	if (!r1) { debugf("SameResourceRecord ERROR: r1 is NULL"); return(false); }	if (!r2) { debugf("SameResourceRecord ERROR: r2 is NULL"); return(false); }	if (r1->RecordType == kDNSRecordTypeConflict)		{ debugf("SameResourceRecord ERROR: r1 is kDNSRecordTypeConflict"); return(false); }	if (r2->RecordType == kDNSRecordTypeConflict)		{ debugf("SameResourceRecord ERROR: r2 is kDNSRecordTypeConflict"); return(false); }	if (r1->rrtype  != r2->rrtype ) return(false);	if (r1->rrclass != r2->rrclass) return(false);	if (r1->rdlength != r2->rdlength) return(false);	if (!sameDomainName(&r1->name, &r2->name)) return(false);	return(SameRData(r1->rrtype, r1->rdlength, &r1->rdata, &r2->rdata));	}// ResourceRecord *q is the ResourceRecord from the duplicate suppression section of the query// ResourceRecord *rr is the answer we are proposing to give, if not suppressedlocal Boolean SuppressDuplicate(const ResourceRecord *const q, const ResourceRecord *const rr)	{	if (!q)  { debugf("SuppressDuplicate ERROR: q is NULL");  return(true); }	if (!rr) { debugf("SuppressDuplicate ERROR: rr is NULL"); return(true); }	if (rr->RecordType == kDNSRecordTypeConflict)		{ debugf("SuppressDuplicate ERROR: kDNSRecordTypeConflict record in list"); return(true); }	if (q->rrtype  != rr->rrtype )                return(false);		// If type different, don't suppress	if (q->rrclass != rr->rrclass)                return(false);		// If class different, don't suppress	if (q->rroriginalttl < rr->rroriginalttl / 2) return(false);		// If TTL too small, don't suppress	if (q->rroriginalttl > rr->rroriginalttl)     return(false);		// If TTL too big, don't suppress	if (q->rdlength != rr->rdlength)              return(false);		// If rd length different, don't suppress	if (!sameDomainName(&q->name, &rr->name))     return(false);		// If name different, don't suppress	return(SameRData(q->rrtype, q->rdlength, &q->rdata, &rr->rdata));	// Suppress only if rdata is identical	}local UInt32 GetNativeRDLength(const ResourceRecord *const rr)	{	switch (rr->rrtype)		{		case kDNSType_A:	return(sizeof(rr->rdata.ip)); break;		case kDNSType_CNAME:// Same as PTR		case kDNSType_PTR:	return(DomainNameLength(&rr->rdata.name));		case kDNSType_TXT:  return(rr->rdlength);	// For TXT, just have to trust what's already in the record		case kDNSType_SRV:	return(6 + DomainNameLength(&rr->rdata.srv.target));		default:			debugf("Warning! Don't know how to get length of resource type %d", rr->rrtype);							return(rr->rdlength);		}	}// ***************************************************************************#pragma mark -#pragma mark - Packet Sending Functionslocal mStatus mDNSSendDNSMessage(const mDNS *const m, DNSMessage *const msg, const void *const end, IPAddr src, IPAddr dst, IPPort port)	{	mStatus status;	UInt16 numQuestions   = msg->h.numQuestions;	UInt16 numAnswers     = msg->h.numAnswers;	UInt16 numAuthorities = msg->h.numAuthorities;	UInt16 numAdditionals = msg->h.numAdditionals;		// Put all the integer values in IETF byte-order (MSB first, LSB second)	UInt8 *ptr = (UInt8 *)&msg->h.numQuestions;	*ptr++ = numQuestions >> 8;	*ptr++ = numQuestions & 0xFF;	*ptr++ = numAnswers >> 8;	*ptr++ = numAnswers & 0xFF;	*ptr++ = numAuthorities >> 8;	*ptr++ = numAuthorities & 0xFF;	*ptr++ = numAdditionals >> 8;	*ptr++ = numAdditionals & 0xFF;		// Send the packet on the wire	status = mDNSPlatformSendUDP(m, msg, end, src, dst, port);		// Put all the integer values back the way they were before we return	msg->h.numQuestions   = numQuestions;	msg->h.numAnswers     = numAnswers;	msg->h.numAuthorities = numAuthorities;	msg->h.numAdditionals = numAdditionals;	return(status);	}// GenerateResponse examines a received query to see if we have any answers to givelocal UInt8 *GenerateResponse(const mDNS *const m, const DNSMessage *const query, const UInt8 *const end, const IPAddr interface,	DNSMessage *const response, Boolean *randomdelay, const SInt32 timenow)	{	static const Opaque16 ResponseFlags = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_Query, 0 } };	const UInt8 *      ptr;	      UInt8 *      responseptr = response->data;	const UInt8 *const limit       = response->data + sizeof(response->data);	int i,j;	DNSQuestion q;	ResourceRecord pktrr, *rr;	#define MaxResponseRecords 100	ResourceRecordPtr records[MaxResponseRecords];	// Keep track of the records we're going to put into this packet	const UInt8      *recinfo[MaxResponseRecords];	// And additional info about them (NULL if answer suppressed)	int putrecords = 0, firstadditional = 0;		if (query->h.numQuestions == 0) debugf("DNS query packet has no Questions in it!");	if (query->h.numAnswers)        debugf("DNS query packet has Answers in it -- check duplicate suppression");	if (query->h.numAuthorities)    debugf("DNS query packet has Authorities in it!");	if (query->h.numAdditionals)    debugf("DNS query packet has Additionals in it!");		// Initialize the response fields so we can answer the questions	InitializeDNSMessage(&response->h, query->h.id, ResponseFlags);	// ***	// *** 1. Build our list of records that answer the questions in the query	// ***	ptr = query->data;	for (i=0; i<query->h.numQuestions; i++)					// For each question...		{		ptr = getQuestion(query, ptr, end, interface, &q);	// get the question...		if (!ptr) return(NULL);				for (rr=m->ResourceRecords; rr; rr=rr->next)		// and search our list of resource records			{			if (ResourceRecordAnswersQuestion(rr, &q))		// If this record answers the question...				{				// If it is not already in our list, append this record to our list of potential answers				for (j=0; j<putrecords; j++) if (records[j] == rr) break;				if (j >= putrecords && putrecords < MaxResponseRecords)					{					records[putrecords] = rr;				// Note the record we're proposing to give					recinfo[putrecords] = ptr;				// And a handle to indicate the question it answers					putrecords++;					}				}			}		}	// ***	// *** 2. Cancel any answers disallowed by duplicate suppression	// ***	for (i=0; i<query->h.numAnswers; i++)					// For each record in the query's answer section...		{		ptr = getResourceRecord(response, ptr, end, interface, timenow, kDNSRecordTypePacketAnswer, &pktrr); // get the record...		if (!ptr) return(NULL);		for (j=0; j<putrecords; j++)						// and see if it suppresses any of our planned answers			if (recinfo[j] && SuppressDuplicate(&pktrr, records[j])) recinfo[j] = NULL;		}	// ***	// *** 3. Write out the list of questions we are actually going to answer, now that we've done duplicate suppression	// ***	ptr = query->data;	for (i=0; i<query->h.numQuestions; i++)					// For each question...		{		ptr = getQuestion(query, ptr, end, interface, &q);	// get the question...		if (!ptr) return(NULL);		for (j=0; j<putrecords; j++)						// and search our list of proposed answers			{			if (recinfo[j] == ptr)							// If we're going to generate a record answering this question				{											// then put the question in the question section				responseptr = putQuestion(response, responseptr, limit, &q.name, q.rrtype, q.rrclass);				if (!responseptr) { debugf("Ran out of space for questions in DNS response!"); return(NULL); }				break;	// break out of the putrecords loop, and go on to the next question				}			}		}	// If we could answer none of the questions, then we have no answer to send	if (response->h.numQuestions == 0) return(NULL);	// ***	// *** 4. Add additional records to our list of proposed records to go in the reply	// ***	firstadditional = putrecords;	for (i=0; i<putrecords; i++)							// For each record we planned to put		{		// If it has not been suppressed, and it has an 'additional' link, pointing to a valid record...		// (Note: This is an "if", not a "while". If we add a record, we'll find it again		// later in the "for" loop, and we will follow further "additional" links then.)		if (recinfo[i] && records[i]->additional && records[i]->additional->RecordType != kDNSRecordTypeConflict)			{			// ... and this additional record is not already in our list, then add it			rr = records[i]->additional;			for (j=0; j<putrecords; j++) if (records[j] == rr) break;			if (j >= putrecords && putrecords < MaxResponseRecords)				{				records[putrecords] = rr;			// Note the record we're proposing to give				recinfo[putrecords] = ptr;			// Set recinfo non-NULL				putrecords++;				}			}		}	// ***	// *** 5. Cancel any additionals disallowed by duplicate suppression	// ***	for (i=0; i<query->h.numAnswers; i++)	// For each record in the query's answer section...		{		ptr = getResourceRecord(response, ptr, end, interface, timenow, kDNSRecordTypePacketAnswer, &pktrr);		// get the record...		if (!ptr) return(NULL);		for (j=firstadditional; j<putrecords; j++)			if (recinfo[j] && SuppressDuplicate(&pktrr, records[j])) recinfo[j] = NULL;		}	// ***	// *** 6. Answer section	// ***	for (i=0; i<firstadditional; i++)		{		if (recinfo[i])			{			responseptr = putResourceRecord(response, responseptr, limit, &response->h.numAnswers, records[i]);			if (!responseptr) { debugf("Ran out of space for answers in DNS response!"); return(NULL); }			if (records[i]->RecordType == kDNSRecordTypeShared) *randomdelay = true;			}		}	// ***	// *** 7. Additional section	// ***	for (i=firstadditional; i<putrecords; i++)		{		if (recinfo[i])			{			UInt8 *p = putResourceRecord(response, responseptr, limit, &response->h.numAdditionals, records[i]);			if (!p) debugf("Ran out of space for additionals in DNS response (will continue)");			else responseptr = p;			}		}	return(responseptr);	}local Boolean AnswersToSend(const mDNS *const m, const SInt32 timenow)	{	ResourceRecord *rr;	for (rr = m->ResourceRecords; rr; rr=rr->next)		{		if (rr->RecordType == kDNSRecordTypeDeregistering) return(true);		if (rr->RecordType == kDNSRecordTypeShared && ResourceRecordAdditionalValid(rr) &&			rr->PacketCount && timenow - rr->NextSendTime >= 0) return(true);		if (rr->SendPriority >= kDNSSendPriorityAnswer && ResourceRecordIsValidForAnswer(rr)) return(true);		}	return(false);	}local Boolean ProbesToSend(const mDNS *const m, const SInt32 timenow)	{	ResourceRecord *rr;	for (rr = m->ResourceRecords; rr; rr=rr->next)		// Scan our list of records		if (rr->RecordType == kDNSRecordTypeUnique && rr->PacketCount && timenow - rr->NextSendTime >= 0)			return(true);	return(false);	}local Boolean QuestionsToSend(const mDNS *const m, const SInt32 timenow)	{	DNSQuestion *q;	for (q = m->ActiveQuestions; q; q=q->next)		// Scan our list of questions		if (timenow - q->NextSendTime >= 0)			return(true);	return(false);	}// This routine sends as many records as it can fit in a single DNS Response Message, in order of priority.// If there are any deregistrations, announcements, or answers that don't fit, they are left in the work list for next time.// If there are any additionals that don't fit, they are discarded -- they were optional anyway.local void sendAnswers(mDNS *const m, const SInt32 timenow)	{	static const Opaque16 AnnouncementFlags = { { kDNSFlag0_QR_Response | kDNSFlag0_OP_Query, 0 } };	static const Opaque16 ZeroID = { { 0, 0 } };	ResourceRecord *rr;	DNSMessage response;	UInt8 *newptr;	UInt8 *responseptr = response.data;	UInt8 *limit       = response.data + sizeof(response.data);	ResourceRecord **p = &m->ResourceRecords;		InitializeDNSMessage(&response.h, ZeroID, AnnouncementFlags);		// 1. Look for deregistrations we need to send	while (*p)		{		rr = *p;		if (rr->RecordType == kDNSRecordTypeDeregistering &&			(newptr = putResourceRecord(&response, responseptr, limit, &response.h.numAnswers, rr)))				{				responseptr = newptr;				rr->RecordType = kDNSRecordTypeUnregistered;				*p = (*p)->next;	// We deregistered this record: Cut it from the list now				}		else			p=&(*p)->next;		}	// 2. Look for announcements we are due to send in the next half second	for (rr = m->ResourceRecords; rr; rr=rr->next)		{		if (rr->RecordType == kDNSRecordTypeShared && ResourceRecordAdditionalValid(rr) &&			rr->PacketCount && timenow + mDNSPlatformOneSecond/2 - rr->NextSendTime >= 0 &&			(newptr = putResourceRecord(&response, responseptr, limit, &response.h.numAnswers, rr)))				{				responseptr = newptr;				rr->SendPriority = 0;				rr->PacketCount--;				rr->NextSendTime = timenow + rr->NextSendInterval;				rr->NextSendInterval *= 2;				}		}	// 3. Look for answers we need to send	for (rr = m->ResourceRecords; rr; rr=rr->next)		if (rr->SendPriority == kDNSSendPriorityAnswer && ResourceRecordIsValidForAnswer(rr) &&			(newptr = putResourceRecord(&response, responseptr, limit, &response.h.numAnswers, rr)))				{ responseptr = newptr; rr->SendPriority = 0; }	// We *never* send a packet with only additionals in it	if (responseptr == response.data)		{		debugf("sendAnswers: Why is the packet is empty?");		return;		}	// 4. Add additionals, if there's space	for (rr = m->ResourceRecords; rr; rr=rr->next)		if (rr->SendPriority == kDNSSendPriorityAdditional)			{			if (ResourceRecordIsValidForAnswer(rr) &&				(newptr = putResourceRecord(&response, responseptr, limit, &response.h.numAnswers, rr)))					responseptr = newptr;			rr->SendPriority = 0;	// Clear SendPriority anyway, even if we didn't put the additional in the packet			}	mDNSSendDNSMessage(m, &response, responseptr, zeroIPAddr, AllDNSLinkGroup, NameServerPort);	debugf("sendAnswers Sent %d Deregistrations/Announcements/Answers/Additionals", response.h.numAnswers);	}local void sendProbes(const mDNS *const m, const SInt32 timenow)	{	static const Opaque16 ProbeFlags = { { kDNSFlag0_QR_Query | kDNSFlag0_OP_Query, 0 } };	static const Opaque16 ZeroID = { { 0, 0 } };	ResourceRecord *rr;	DNSMessage query;	UInt8 *queryptr = query.data;	UInt8 *limit    = query.data + sizeof(query.data);		InitializeDNSMessage(&query.h, ZeroID, ProbeFlags);	for (rr = m->ResourceRecords; rr; rr=rr->next)		// Scan our list of records		{		if (rr->RecordType == kDNSRecordTypeUnique && rr->PacketCount && timenow + mDNSPlatformOneSecond/2 - rr->NextSendTime >= 0)			{			// If that was our last probe we just completed successfully without conflict,			// then set PacketCount to zero to make the record active			if (rr->PacketCount == 1) rr->PacketCount = 0;			else	// Else, generate another probe packet and decrement PacketCount				{				UInt8 *newptr = putQuestion(&query, queryptr, limit, &rr->name, rr->rrtype, rr->rrclass);				if (newptr)					{					queryptr = newptr;					rr->PacketCount--;		// Only decrement PacketCount if we successfully added the record to the packet					rr->NextSendTime = timenow + rr->NextSendInterval;					}				}			}		}	if (queryptr > query.data)		{		mDNSSendDNSMessage(m, &query, queryptr, zeroIPAddr, AllDNSLinkGroup, NameServerPort);		debugf("sendProbes Sent %d probe questions", query.h.numQuestions);		}	else		debugf("sendProbes: Why is the packet is empty?");	}local void sendQuestions(const mDNS *const m, const SInt32 timenow)	{	static const Opaque16 ProbeFlags = { { kDNSFlag0_QR_Query | kDNSFlag0_OP_Query, 0 } };	static const Opaque16 ZeroID = { { 0, 0 } };	DNSQuestion *q;	DNSMessage query;	UInt8 *queryptr = query.data;	UInt8 *limit    = query.data + sizeof(query.data);		InitializeDNSMessage(&query.h, ZeroID, ProbeFlags);	for (q = m->ActiveQuestions; q; q=q->next)		// Scan our list of questions		{		if (timenow + mDNSPlatformOneSecond/2 - q->NextSendTime >= 0)			{			UInt8 *newptr = putQuestion(&query, queryptr, limit, &q->name, q->rrtype, q->rrclass);			if (newptr)				{				queryptr = newptr;				q->NextSendTime += q->NextSendInterval;				q->NextSendInterval *= 2;				if (q->NextSendInterval > 60*60)					q->NextSendInterval = 60*60;	// For now, cap interval between questions to no more than one minute				}			}		}	if (queryptr > query.data)		{		mDNSSendDNSMessage(m, &query, queryptr, zeroIPAddr, AllDNSLinkGroup, NameServerPort);		debugf("sendQuestions Sent %d questions", query.h.numQuestions);		}	else		debugf("sendQuestions: Why is the packet is empty?");	}// ***************************************************************************#pragma mark -#pragma mark - Cache & Task Management Functionslocal UInt32 CountOfCacheRecords(const mDNS *const m)	{	ResourceRecord *c = m->rrcache;	UInt32 count = 0;	for (c=m->rrcache; c; c=c->next) count++;	return(count);	}local void AnswerQuestionWithResourceRecord(mDNS *const m, DNSQuestion *q, ResourceRecord *rr, const SInt32 timenow)	{	SInt32 timesincercvd = timenow - rr->TimeRcvd;	debugf("AnswerQuestionWithResourceRecord for %##s", rr->name.c);	if (rr->rroriginalttl <= timesincercvd / mDNSPlatformOneSecond) rr->rrremainingttl = 0;	else rr->rrremainingttl = rr->rroriginalttl - timesincercvd / mDNSPlatformOneSecond;	rr->LastUsed = timenow;	if (q->callback) q->callback(m, q, rr, q->context);	}// AnswerLocalQuestions is called from mDNSCoreReceiveResponse,// and from TidyRRCache, which is called from mDNSCoreTask and from mDNSCoreReceiveResponse// AnswerLocalQuestions is *never* called directly as a result from withing a client API call// If new questions are created as a result of invoking client callbacks, they will be added to// the end of the question list, and m->NewQuestions will be set to indicate the first new question.local void AnswerLocalQuestions(mDNS *const m, ResourceRecord *rr, const SInt32 timenow)	{	if (m->CurrentQuestion) debugf("AnswerLocalQuestions ERROR m->CurrentQuestion already set");	m->CurrentQuestion = m->ActiveQuestions;	while (m->CurrentQuestion && m->CurrentQuestion != m->NewQuestions)		{		DNSQuestion *q = m->CurrentQuestion;		m->CurrentQuestion = q->next;		if (ResourceRecordAnswersQuestion(rr, q))			AnswerQuestionWithResourceRecord(m, q, rr, timenow);		}	m->CurrentQuestion = NULL;	}local void AnswerNewQuestions(mDNS *const m, const SInt32 timenow)	{	ResourceRecord *rr;	DNSQuestion *q = m->NewQuestions;		// Grab the question we're going to answer	m->NewQuestions = q->next;				// Advance NewQuestions to the next (if any)	if (m->lock_rrcache) debugf("mDNSCoreTask ERROR! Cache already locked!");	// This should be safe, because calling the client's question callback may cause the	// question list to be modified, but should not ever cause the rrcache list to be modified.	// If the client's question callback deletes the question, then m->CurrentQuestion will	// be advanced, and we'll exit out of the loop	m->lock_rrcache = 1;	m->CurrentQuestion = q;		// Indicate which question we're answering, so we'll know if it gets deleted	for (rr=m->rrcache; rr && m->CurrentQuestion == q; rr=rr->next)		if (ResourceRecordAnswersQuestion(rr, q))			AnswerQuestionWithResourceRecord(m, q, rr, timenow);	m->CurrentQuestion = NULL;	m->lock_rrcache = 0;	}// TidyRRCache// Throw away any cache records that have passed their TTL// First we prepare a list of records to delete, and pull them off the rrcache list// Then we go through the list of records to delete, calling the user's question callbacks if necessary// We do it in two phases like this to guard against the user's question callbacks modifying// the rrcache list while we're walking it.local void TidyRRCache(mDNS *const m, const SInt32 timenow)	{	UInt32 count = 0;	ResourceRecord **rr = &m->rrcache;	ResourceRecord *deletelist = NULL;		if (m->lock_rrcache) { debugf("TidyRRCache ERROR! Cache already locked!"); return; }	m->lock_rrcache = 1;		while (*rr)		{		SInt32 timesincercvd = timenow - (*rr)->TimeRcvd;		if ((*rr)->rroriginalttl > timesincercvd / mDNSPlatformOneSecond)			rr=&(*rr)->next;			// If TTL is greater than time elapsed, save this record		else			{			ResourceRecord *r = *rr;	// Else,			*rr = r->next;				// detatch this record from the cache list			r->next = deletelist;		// and move it onto the list of things to delete			deletelist = r;			count++;			}		}		if (count) debugf("TidyRRCache Deleting %d Expired Cache Entries", count);	m->lock_rrcache = 0;		while (deletelist)		{		ResourceRecord *r = deletelist;		debugf("TidyRRCache Deleted %##s", r->name.c);		deletelist = deletelist->next;		AnswerLocalQuestions(m, r, timenow);		r->next = m->rrcache_free;	// and move it back to the free list		m->rrcache_free = r;		}	}local ResourceRecord *GetFreeCacheRR(mDNS *const m, const SInt32 timenow)	{	ResourceRecord *r = m->rrcache_free;	if (m->lock_rrcache) { debugf("GetFreeCacheRR ERROR! Cache already locked!"); return(NULL); }	m->lock_rrcache = 1;		if (r)		// If there are records in the free list, take one		m->rrcache_free = r->next;	else		// Else search for a candidate to recycle		{		ResourceRecord **rr = &m->rrcache;		ResourceRecord **best = NULL;		ResourceRecord **bestanswer = NULL;		ResourceRecord **bestadditional = NULL;		SInt32 leastrecentanswer = -1;		SInt32 leastrecentadditional = -1;		while (*rr)			{			SInt32 timesincercvd = timenow - (*rr)->TimeRcvd;			SInt32 timesinceused = timenow - (*rr)->LastUsed;			// If we found a record *past* (not at) its expiration time, we can use it.			if (timesincercvd / mDNSPlatformOneSecond > (*rr)->rroriginalttl)				{ best = rr; break; }			// Records we've only just received are not candidates for deletion			if (timesincercvd > 0)				{				if ((*rr)->RecordType == kDNSRecordTypePacketAnswer && leastrecentanswer < timesinceused)					{ bestanswer = rr; leastrecentanswer = timesinceused; }				if ((*rr)->RecordType == kDNSRecordTypePacketAdditional && leastrecentadditional < timesinceused)					{ bestadditional = rr; leastrecentadditional = timesinceused; }				}			rr=&(*rr)->next;			}		if (!best) best = bestadditional;	// If didn't find an expired one, try oldest additional		if (!best) best = bestanswer;		// If didn't find an additional, try oldest answer		if (best)			{			r = *best;							// Remember the record we chose			*best = r->next;					// And detatch it from the free list			}		}	m->lock_rrcache = 0;	if (r) mDNSPlatformMemZero(r, sizeof(*r));	return(r);	}local void ScheduleNextTask(const mDNS *const m)	{	const SInt32 timenow = mDNSPlatformTimeNow();	SInt32 nextevent = timenow + 0x3FFFFFFF;	const char *msg = "No Event", *sign="";	SInt32 interval, fraction;	DNSQuestion *q;	ResourceRecord *rr;		// 1. If we have new questions added to the list, we need to answer them from cache ASAP	if (m->NewQuestions)		{		nextevent = timenow;		msg = "New Questions";		}	else		{		// 2. Scan cache to see if any resource records are going to expire		for (rr = m->rrcache; rr; rr=rr->next)			{			SInt32 expire = rr->TimeRcvd + rr->rroriginalttl * mDNSPlatformOneSecond;			if (nextevent - expire > 0)				{				nextevent = expire;				msg = "Cache Tidying";				}			}				// If we're suppressing sending right now, don't bother searching for packet generation events --		// but do make sure we come back at the end of the suppression time to check again		if (m->SuppressSending)			{			if (nextevent - m->SuppressSending > 0)				{				nextevent = m->SuppressSending;				msg = "Send Suppressed Packets";				}			}		else			{			// 2. Scan list of active questions to see if we need to send any queries			for (q = m->ActiveQuestions; q; q=q->next)				if (nextevent - q->NextSendTime > 0)					{					nextevent = q->NextSendTime;					msg = "Send Questions";					}			// 3. Scan list of local resource records to see if we have any announcements, probes or replies to send			for (rr = m->ResourceRecords; rr; rr=rr->next)				{				// Check if this record is scheduled for reply				if (rr->SendPriority >= kDNSSendPriorityAnswer)					{					nextevent = timenow;					msg = "Send Answers";					}				// Check if this record is scheduled for periodic announcement or probe				switch (rr->RecordType)					{					case kDNSRecordTypeDeregistering:	nextevent = timenow; msg = "Send Deregistrations"; break;					case kDNSRecordTypeShared:			if (ResourceRecordAdditionalValid(rr) &&															rr->PacketCount && nextevent - rr->NextSendTime > 0)															{															nextevent = rr->NextSendTime;															msg = "Send Announcements";															}														break;					case kDNSRecordTypeUnique:			if (rr->PacketCount && nextevent - rr->NextSendTime > 0)															{															nextevent = rr->NextSendTime;															msg = "Send Probes";															}														break;					case kDNSRecordTypeKnownUnique:		break;	// No announcement or probe for KnownUnique records					case kDNSRecordTypeConflict:		break;	// No announcement or probe for Conflicted records					default: debugf("ScheduleNextTask: What is RecordType %d doing in ResourceRecords list?", rr->RecordType); break;					}				}			}		}	interval = nextevent - timenow;	if (interval < 0) { interval = -interval; sign = "-"; }	fraction = interval % mDNSPlatformOneSecond;	//debugf("ScheduleNextTask: Next event: <%s> in %s%d.%03d seconds", msg, sign,	//	interval / mDNSPlatformOneSecond, fraction * 1000 / mDNSPlatformOneSecond);	mDNSPlatformScheduleTask(m, nextevent);	}export void mDNSCoreTask(mDNS *const m)	{	if (m->mDNSPlatformStatus == mStatus_NoError)		{		const SInt32 timenow = mDNSPlatformTimeNow();		if (++m->mDNS_busy > 1) debugf("mDNSCoreTask: Locking failure! mDNS already busy");		if (m->CurrentQuestion) debugf("mDNSCoreTask: ERROR! m->CurrentQuestion already set");		while (m->NewQuestions) AnswerNewQuestions(m, timenow);		if (m->SuppressSending == 0 || timenow - m->SuppressSending >= 0)			{			m->SuppressSending = 0;			if (AnswersToSend  (m, timenow)) sendAnswers  (m, timenow);			if (ProbesToSend   (m, timenow)) sendProbes   (m, timenow);			if (QuestionsToSend(m, timenow)) sendQuestions(m, timenow);			}		if (m->rrcache_size) TidyRRCache(m, timenow);		// Now we've completed this set of tasks, set up the callback for the next task(s)		if (--m->mDNS_busy == 0) ScheduleNextTask(m);		}	}local SInt32 mDNS_Lock(mDNS *const m)	{	mDNSPlatformLock(m);	++m->mDNS_busy;	return(mDNSPlatformTimeNow());	}local void mDNS_Unlock(mDNS *const m)	{	// Upon unlocking, we've usually added some new work to the task list.	// If we don't decrement mDNS_busy to zero, then we don't have to worry about calling ScheduleNextTask(),	// because the last lock holder will do it for us on the way out	if (--m->mDNS_busy == 0) ScheduleNextTask(m);	mDNSPlatformUnlock(m);	}// ***************************************************************************#pragma mark -#pragma mark - Packet Reception Functionslocal void mDNSCoreReceiveQuery(const mDNS *const m, const DNSMessage *const msg, const UInt8 *const end, const IPAddr srcaddr, const IPPort srcport, const IPAddr dstaddr, const IPAddr interface)	{	const SInt32 timenow = mDNSPlatformTimeNow();	Boolean randomdelay = false;	DNSMessage response;	const UInt8 *const responseend = GenerateResponse(m, msg, end, interface, &response, &randomdelay, timenow);	if (responseend)		{		Boolean replymulticast = false;		Boolean replyunicast   = false;				// If this was a multicast query, reply by multicast, else if unicast query, no random delay required and reply by unicast		if ((dstaddr.b[0] & 0xF0) == 0xE0) replymulticast = true;		else { randomdelay = false; replyunicast = true; }		// If we got this from an old (non-port-5353) client then make sure we send a unicast response as well, or it won't see the reply		if (srcport.NotAnInteger != NameServerPort.NotAnInteger) replyunicast = true;				// Note: No need for random delay on unicast replies		if (replymulticast) mDNSSendDNSMessage(m, &response, responseend, zeroIPAddr, AllDNSLinkGroup, NameServerPort);		if (replyunicast)   mDNSSendDNSMessage(m, &response, responseend, zeroIPAddr, srcaddr,         srcport);		}	}local void mDNSCoreReceiveResponse(mDNS *const m, const DNSMessage *const response, const UInt8 *end, const IPAddr srcaddr, const IPPort srcport, const IPAddr dstaddr, const IPAddr interface)	{	#pragma unused (srcaddr)	#pragma unused (srcport)	#pragma unused (dstaddr)	#pragma unused (interface)	int i;	const SInt32 timenow = mDNSPlatformTimeNow();		// We ignore questions (if any) in a DNS response packet	const UInt8 *ptr = locateDNSanswers(response, end);	// All records in a DNS response packet are treated as equally valid statements of truth.	// If we want to guard against spoof replies, then the only credible protection against that is cryptographic	// security, e.g. DNSSEC., not worring about which section in the spoof packet contained the record	UInt16 totalrecords = response->h.numAnswers + response->h.numAuthorities + response->h.numAdditionals;	for (i = 0; i < totalrecords && ptr && ptr < end; i++)		{		ResourceRecord *rr;		ResourceRecord pktrr;		UInt8 RecordType = (i < response->h.numAnswers) ? kDNSRecordTypePacketAnswer : kDNSRecordTypePacketAdditional;		ptr = getResourceRecord(response, ptr, end, interface, timenow, RecordType, &pktrr);		if (!ptr) return;		// 1. Check that this packet resource record does not conflict with any of ours		for (rr = m->ResourceRecords; rr; rr=rr->next)			{			int result = ResourceRecordConflict(&pktrr, rr);			if (result == +1) debugf("ResourceRecord conflict: We won");			if (result == -1)				{				debugf("ResourceRecord conflict: We lost");				rr->RecordType = kDNSRecordTypeConflict;				if (rr->collision) rr->collision(m, rr);				}			}		if (m->rrcache_size)	// Only try to cache answers if we have a cache to put them in			{			// 2. Check if this packet resource record is already in our cache			for (rr = m->rrcache; rr; rr=rr->next)				{				// If we found this exact resource record, refresh its TTL				if (SameResourceRecord(&pktrr, rr))					{					// debugf("Found RR %##s already in cache", pktrr.name.c);					rr->TimeRcvd = timenow;					rr->rroriginalttl = pktrr.rroriginalttl;					break;					}				}			// If packet resource record not in our cache, add it now			if (!rr)				{				rr = GetFreeCacheRR(m, timenow);				if (!rr) debugf("No cache space to add record for %#s", pktrr.name.c);				else					{					*rr = pktrr;					rr->next = m->rrcache;					m->rrcache = rr;					//debugf("Adding RR %##s to cache (%d)", pktrr.name.c, CountOfCacheRecords(m));					AnswerLocalQuestions(m, rr, timenow);					}				}			}		}	TidyRRCache(m, timenow);	}export void mDNSCoreReceive(mDNS *const m, DNSMessage *const msg, const void *const end, IPAddr srcaddr, IPPort srcport, IPAddr dstaddr, IPAddr interface)	{	UInt8 flags = msg->h.flags.b[0] & kDNSFlag0_QROP_Mask;		// Read the integer parts which are in IETF byte-order (MSB first, LSB second)	UInt8 *ptr = (UInt8 *)&msg->h.numQuestions;	msg->h.numQuestions   = (UInt16)ptr[0] <<  8 | ptr[1];	msg->h.numAnswers     = (UInt16)ptr[2] <<  8 | ptr[3];	msg->h.numAuthorities = (UInt16)ptr[4] <<  8 | ptr[5];	msg->h.numAdditionals = (UInt16)ptr[6] <<  8 | ptr[7];		if (++m->mDNS_busy > 1) debugf("mDNSCoreReceive: Locking failure! mDNS already busy");	if      (flags == (kDNSFlag0_QR_Query    | kDNSFlag0_OP_Query)) mDNSCoreReceiveQuery   (m, msg, end, srcaddr, srcport, dstaddr, interface);	else if (flags == (kDNSFlag0_QR_Response | kDNSFlag0_OP_Query)) mDNSCoreReceiveResponse(m, msg, end, srcaddr, srcport, dstaddr, interface);	else debugf("Unknown DNS packet type %X (ignored)", msg->h.flags.NotAnInteger);	// Packet reception often causes a change to the task list:	// 1. Inbound queries can cause us to need to send responses	// 2. Conflicing response packets received from other hosts can cause us to need to send defensive responses	// 3. Other hosts announcing deletion of shared records can cause us to need to re-assert those records	// 4. Response packets that answer questions may cause our client to issue new questions	if (--m->mDNS_busy == 0) ScheduleNextTask(m);	}// ***************************************************************************#pragma mark -#pragma mark - Searcher Functionslocal mStatus mDNS_StartQuery_internal(mDNS *const m, DNSQuestion *const question)	{	// Can't do queries if we have no cache space allocated	if (m->rrcache_size == 0)		return(mStatus_NoCache);	else		{		//ResourceRecord *rr;		DNSQuestion **q = &m->ActiveQuestions;		while (*q && *q != question) q=&(*q)->next;		if (*q)			{			debugf("Error! Tried to add a question that's already in the active list");			return(mStatus_AlreadyRegistered);			}		question->next             = NULL;		question->NextSendTime     = mDNSPlatformTimeNow();		question->NextSendInterval = mDNSPlatformOneSecond;		*q = question;				if (!m->NewQuestions) m->NewQuestions = question;#if 0		if (m->lock_rrcache) { debugf("mDNS_StartQuery_internal ERROR! Cache already locked!"); return(mStatus_NoCache); }		m->lock_rrcache = 1;		// This should be safe, because calling the user's question callback may cause the		// question list to be modified, but should not ever cause the rrcache list to be modified.		for (rr=m->rrcache; rr && question->NextSendInterval; rr=rr->next)			if (ResourceRecordAnswersQuestion(rr, question))				AnswerQuestionWithResourceRecord(m, question, rr, timenow);		m->lock_rrcache = 0;#endif		return(mStatus_NoError);		}	}local void mDNS_StopQuery_internal(mDNS *const m, DNSQuestion *const question)	{	DNSQuestion **q = &m->ActiveQuestions;	while (*q && *q != question) q=&(*q)->next;	if (*q) *q = (*q)->next;	question->next = NULL;	question->NextSendInterval = 0;		// If we just deleted the question that AnswerLocalQuestions() is about to look at,	// bump its pointer forward one question.	if (m->CurrentQuestion == question)		{		debugf("mDNS_StopQuery_internal: Just deleted the currently active question.");		m->CurrentQuestion = m->CurrentQuestion->next;		}	if (m->NewQuestions    == question)		{		debugf("mDNS_StopQuery_internal: Just deleted a new question that wasn't even answered yet.");		m->NewQuestions    = m->NewQuestions->next;		}	}export mStatus mDNS_StartQuery(mDNS *const m, DNSQuestion *const question)	{	const SInt32 timenow = mDNS_Lock(m);	mStatus status = mDNS_StartQuery_internal(m, question);	mDNS_Unlock(m);	return(status);	}export void mDNS_StopQuery(mDNS *const m, DNSQuestion *const question)	{	const SInt32 timenow = mDNS_Lock(m);	mDNS_StopQuery_internal(m, question);	mDNS_Unlock(m);	}export mStatus mDNS_StartBrowse(mDNS *m, DNSQuestion *const question,	const char *const srv, const char *const domain, const IPAddr interface, mDNSAnswerCallback *callback, void *context)	{	question->interface = interface;	question->name.c[0] = 0;	AppendStringNameToName(&question->name, srv);	AppendStringNameToName(&question->name, domain);	question->rrtype    = kDNSType_PTR;	question->rrclass   = kDNSClass_IN;	question->callback  = callback;	question->context   = context;	return(mDNS_StartQuery(m, question));	}local void FoundServiceInfoSRV(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, void *context)	{	#pragma unused (question)	ServiceInfoQuery *query = (ServiceInfoQuery *)context;//	const SInt32 timenow = mDNSPlatformTimeNow();	debugf("FoundServiceInfoSRV");	if (answer->rrremainingttl == 0) return;	if (answer->rrtype != kDNSType_SRV) return;	query->info->port    = answer->rdata.srv.port;	query->qADD.name     = answer->rdata.srv.target;	mDNS_StartQuery_internal(m, &query->qADD);	// Don't need to do ScheduleNextTask because this callback can only ever happen	// (a) as a result of an immediate result from the mDNS_StartQuery call, or	// (b) as a result of receiving a packet on the wire	// both of which will result in a subsequent ScheduleNextTask call of their own	}local void FoundServiceInfoTXT(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, void *context)	{	#pragma unused (question)	ServiceInfoQuery *query = (ServiceInfoQuery *)context;	const SInt32 timenow = mDNSPlatformTimeNow();	debugf("FoundServiceInfoTXT");	if (answer->rrremainingttl == 0) return;	if (answer->rrtype != kDNSType_TXT) return;	query->info->txtinfo = answer->rdata.txt;	query->info->got_txt = true;	if (query->info->got_ip && query->info->got_txt && query->callback)		{		debugf("FoundServiceInfo2: Got both");		query->callback(m, query, query->context);		}	}local void FoundServiceInfoADD(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, void *context)	{	#pragma unused (question)	ServiceInfoQuery *query = (ServiceInfoQuery *)context;	debugf("FoundServiceInfoADD");	if (answer->rrremainingttl == 0) return;	if (answer->rrtype != kDNSType_A) return;	query->info->ip     = answer->rdata.ip;	query->info->got_ip = true;		if (query->info->got_ip && query->info->got_txt && query->callback)		{		debugf("FoundServiceInfo2: Got both");		query->callback(m, query, query->context);		}	}export mStatus mDNS_StartResolveService(mDNS *m, ServiceInfoQuery *query, ServiceInfo *info, ServiceInfoQueryCallback *callback, void *context)	{	const SInt32 timenow = mDNS_Lock(m);	mStatus status;		query->qSRV.interface = info->interface;	query->qSRV.name      = info->name;	query->qSRV.rrtype    = kDNSType_SRV;	query->qSRV.rrclass   = kDNSClass_IN;	query->qSRV.callback  = FoundServiceInfoSRV;	query->qSRV.context   = query;	query->qTXT.interface = info->interface;	query->qTXT.name      = info->name;	query->qTXT.rrtype    = kDNSType_TXT;	query->qTXT.rrclass   = kDNSClass_IN;	query->qTXT.callback  = FoundServiceInfoTXT;	query->qTXT.context   = query;	query->qADD.interface = info->interface;	query->qADD.name.c[0] = 0;	query->qADD.rrtype    = kDNSType_A;	query->qADD.rrclass   = kDNSClass_IN;	query->qADD.callback  = FoundServiceInfoADD;	query->qADD.context   = query;	query->info           = info;	query->callback = callback;	query->context  = context;//	info->name         = Must already be set up by client//	info->interface    = Must already be set up by client	info->ip           = zeroIPAddr;	info->port         = zeroIPPort;	info->got_ip       = false;	info->got_txt      = false;	info->txtinfo.c[0] = 0;	status = mDNS_StartQuery_internal(m, &query->qSRV);	if (status == mStatus_NoError) status = mDNS_StartQuery_internal(m, &query->qTXT);	if (status != mStatus_NoError) mDNS_StopResolveService(m, query);	mDNS_Unlock(m);	return(status);	}export void    mDNS_StopResolveService (mDNS *m, ServiceInfoQuery *query)	{	const SInt32 timenow = mDNS_Lock(m);	mDNS_StopQuery_internal(m, &query->qSRV);	mDNS_StopQuery_internal(m, &query->qTXT);	mDNS_StopQuery_internal(m, &query->qADD);	mDNS_Unlock(m);	}// ***************************************************************************#pragma mark -#pragma mark - Responder Functions// Set up a ResourceRecord with sensible default values.// These defaults may be overwritten with new values before mDNS_Register is calledexport void mDNS_SetupResourceRecord(ResourceRecord *rr, ResourceRecord *additional, IPAddr interface,	UInt16 rrtype, UInt32 ttl)	{	if (interface.b[0] != 169 || interface.b[1] != 254) interface = zeroIPAddr;	// Don't try to store a TTL bigger than we can represent in platform units	if (ttl > 0x7FFFFFFF / mDNSPlatformOneSecond)		ttl = 0x7FFFFFFF / mDNSPlatformOneSecond;	rr->next             = NULL;	rr->additional       = additional;	rr->collision        = NULL;	rr->RecordType       = 0;	rr->PacketCount      = 0;	rr->SendPriority     = 0;	rr->NextSendTime     = 0;	rr->NextSendInterval = 0;	rr->TimeRcvd         = 0;	// Not strictly relevant for a local record	rr->LastUsed         = 0;	// Not strictly relevant for a local record	rr->interface        = interface;	rr->name.c[0]        = 0;	rr->rrtype           = rrtype;	rr->rrclass          = kDNSClass_IN;	rr->rroriginalttl    = ttl;	rr->rrremainingttl   = 0;	rr->rdlength         = 0;	//rr->rdata needs to be filled in by the client before it calls mDNS_Register	}local mStatus mDNS_Register_internal(mDNS *const m, ResourceRecord *const rr, UInt8 RecordType)	{	ResourceRecord **p = &m->ResourceRecords;	while (*p && *p != rr) p=&(*p)->next;	if (*p || rr->RecordType)		{		debugf("Error! Tried to register a ResourceRecord that's already in the list");		return(mStatus_AlreadyRegistered);		}	rr->next             = NULL;//	rr->additional       = already set in mDNS_SetupResourceRecord//	rr->collision        = may be set by client	rr->RecordType       = RecordType;	rr->PacketCount      = 0;	if (RecordType == kDNSRecordTypeUnique) rr->PacketCount = 4;	// Probe three times for uniqueness	if (RecordType == kDNSRecordTypeShared) rr->PacketCount = 10;	// Announce shared records ten times	rr->SendPriority     = 0;	rr->NextSendTime     = mDNSPlatformTimeNow();	rr->NextSendInterval = mDNSPlatformOneSecond;	rr->TimeRcvd         = 0;	// Not strictly relevant for a local record	rr->LastUsed         = 0;	// Not strictly relevant for a local record//	rr->interface        = already set in mDNS_SetupResourceRecord//	rr->name.c[0]        = already set by client//	rr->rrtype           = already set in mDNS_SetupResourceRecord//	rr->rrclass          = already set in mDNS_SetupResourceRecord//	rr->rroriginalttl    = already set in mDNS_SetupResourceRecord	rr->rrremainingttl   = 0;	rr->rdlength         = GetNativeRDLength(rr);//	rr->rdata            = already set by client	*p = rr;	return(mStatus_NoError);	}local void mDNS_Deregister_internal(mDNS *const m, ResourceRecord *const rr)	{	if (rr->RecordType == kDNSRecordTypeShared)		{		rr->RecordType = kDNSRecordTypeDeregistering;		rr->rroriginalttl = 0;		}	else		{		// Find this record in our list of active records		ResourceRecord **p = &m->ResourceRecords;		while (*p && *p != rr) p=&(*p)->next;		if (*p) *p = (*p)->next;		else debugf("mDNS_Deregister: Record not found in list");				if      (rr->RecordType == kDNSRecordTypeUnregistered)			debugf("mDNS_Deregister: Record already marked kDNSRecordTypeUnregistered");		else if (rr->RecordType == kDNSRecordTypeDeregistering)			debugf("mDNS_Deregister: Record already marked kDNSRecordTypeDeregistering");		else			rr->RecordType = kDNSRecordTypeUnregistered;		}	}export mStatus mDNS_Register(mDNS *const m, ResourceRecord *const rr, UInt8 RecordType)	{	const SInt32 timenow = mDNS_Lock(m);	mStatus status = mDNS_Register_internal(m, rr, RecordType);	mDNS_Unlock(m);	return(status);	}export void mDNS_Deregister(mDNS *const m, ResourceRecord *const rr)	{	const SInt32 timenow = mDNS_Lock(m);	mDNS_Deregister_internal(m, rr);	mDNS_Unlock(m);	}export mStatus mDNS_RegisterHost(mDNS *m)	{	const SInt32 timenow = mDNS_Lock(m);	char buffer[256];		mDNS_SetupResourceRecord(&m->RR_A1,  NULL, m->ip, kDNSType_A,   10);	mDNS_SetupResourceRecord(&m->RR_A2,  NULL, m->ip, kDNSType_A,   10);	mDNS_SetupResourceRecord(&m->RR_PTR, NULL, m->ip, kDNSType_PTR, 10);	m->RR_A1.name.c[0] = 0;	AppendDomainLabelToName(&m->RR_A1.name, &m->hostlabel);	AppendStringLabelToName(&m->RR_A1.name, "local");	m->RR_A2.name.c[0] = 0;	AppendDomainLabelToName(&m->RR_A2.name, &m->hostlabel);	AppendStringLabelToName(&m->RR_A2.name, "local");	AppendStringLabelToName(&m->RR_A2.name, "arpa");	mDNS_sprintf(buffer, "%d.%d.%d.%d.in-addr.arpa.", m->ip.b[3], m->ip.b[2], m->ip.b[1], m->ip.b[0]);	ConvertCStringToDomainName(buffer, &m->RR_PTR.name);	m->RR_A1. rdata.ip   = m->ip;	m->RR_A2. rdata.ip   = m->ip;	m->RR_PTR.rdata.name = m->RR_A2.name;	mDNS_Register_internal(m, &m->RR_A1,  kDNSRecordTypeUnique);	mDNS_Register_internal(m, &m->RR_A2,  kDNSRecordTypeUnique);	mDNS_Register_internal(m, &m->RR_PTR, kDNSRecordTypeKnownUnique);	// ... Add an HINFO record?	mDNS_Unlock(m);	return(mStatus_NoError);	}export void mDNS_DeregisterHost(mDNS *m)	{	const SInt32 timenow = mDNS_Lock(m);	mDNS_Deregister_internal(m, &m->RR_A1);	mDNS_Deregister_internal(m, &m->RR_A2);	mDNS_Deregister_internal(m, &m->RR_PTR);	mDNS_Unlock(m);	}// Note:// Name is first label of domain name (any dots in the name are actual dots, not label separators)// Type is service type (e.g. "_printer._tcp.")// Domain is fully qualified domain name (i.e. ending with a null label)// We always register a TXT, even if it is empty (so that clients are not// left waiting forever looking for a nonexistent record.)export mStatus mDNS_RegisterService(mDNS *m, ServiceRecordSet *sr, IPPort port, const char txtinfo[],	const domainlabel *const name, const domainname *const type, const domainname *const domain)	{	const SInt32 timenow = mDNS_Lock(m);	IPAddr interface = { { 0, 0, 0, 0 } };	if (m->ip.b[0] == 169 && m->ip.b[1] == 254) interface = m->ip;		mDNS_SetupResourceRecord(&sr->RR_A,    NULL,        interface,  kDNSType_A,   10);	mDNS_SetupResourceRecord(&sr->RR_SRV,  &sr->RR_A,   zeroIPAddr, kDNSType_SRV, 10); 	mDNS_SetupResourceRecord(&sr->RR_TXT,  &sr->RR_SRV, zeroIPAddr, kDNSType_TXT, 10); 	mDNS_SetupResourceRecord(&sr->RR_ALL,  &sr->RR_TXT, zeroIPAddr, kDNSType_PTR, 3600);	mDNS_SetupResourceRecord(&sr->RR_LINK, &sr->RR_TXT, zeroIPAddr, kDNSType_PTR, 3600);	mDNS_SetupResourceRecord(&sr->RR_HOST, &sr->RR_TXT, zeroIPAddr, kDNSType_PTR, 3600);	ConstructServiceName(&sr->RR_A.name,    name, type, domain);	ConstructServiceName(&sr->RR_SRV.name,  name, type, domain);	ConstructServiceName(&sr->RR_TXT.name,  name, type, domain);	ConvertCStringToDomainName("_all.local.arpa.", &sr->RR_ALL.name);	ConstructServiceName(&sr->RR_LINK.name, NULL, type, domain);	ConstructServiceName(&sr->RR_HOST.name, NULL, type, &m->RR_A2.name);		sr->RR_A.rdata.ip = m->ip;		sr->RR_SRV.rdata.srv.priority = 0;	sr->RR_SRV.rdata.srv.weight   = 0;	sr->RR_SRV.rdata.srv.port     = port;	sr->RR_SRV.rdata.srv.target   = sr->RR_SRV.name;	mDNSPlatformStrCopy(txtinfo,(char *)(sr->RR_TXT.rdata.txt.c));	sr->RR_ALL.rdata.name  = sr->RR_SRV.name;	sr->RR_LINK.rdata.name = sr->RR_SRV.name;	sr->RR_HOST.rdata.name = sr->RR_SRV.name;	mDNS_Register_internal(m, &sr->RR_A,    kDNSRecordTypeUnique);	mDNS_Register_internal(m, &sr->RR_SRV,  kDNSRecordTypeUnique);	mDNS_Register_internal(m, &sr->RR_TXT,  kDNSRecordTypeUnique);	mDNS_Register_internal(m, &sr->RR_ALL,  kDNSRecordTypeShared);	mDNS_Register_internal(m, &sr->RR_LINK, kDNSRecordTypeShared);	mDNS_Register_internal(m, &sr->RR_HOST, kDNSRecordTypeShared);		mDNS_Unlock(m);	return(mStatus_NoError);	}export void mDNS_DeregisterService(mDNS *m, ServiceRecordSet *sr)	{	const SInt32 timenow = mDNS_Lock(m);	mDNS_Deregister_internal(m, &sr->RR_A);	mDNS_Deregister_internal(m, &sr->RR_SRV);	mDNS_Deregister_internal(m, &sr->RR_TXT);	mDNS_Deregister_internal(m, &sr->RR_ALL);	mDNS_Deregister_internal(m, &sr->RR_LINK);	mDNS_Deregister_internal(m, &sr->RR_HOST);	mDNS_Unlock(m);	}// ***************************************************************************#pragma mark -#pragma mark - Startup and Shutdown Functionsexport mStatus mDNS_Init(mDNS *const m, mDNS_PlatformSupport *const p,	ResourceRecord *const rrcachestorage, const UInt32 rrcachesize, mDNSCallback *const initComplete)	{	int i;	m->p                  = p;	m->mDNSPlatformStatus = mStatus_Waiting;	m->initComplete       = initComplete;	m->mDNS_busy          = 0;	m->lock_rrcache       = 0;	m->lock_Questions     = 0;	m->lock_Records       = 0;	m->ActiveQuestions    = NULL;	m->NewQuestions       = NULL;	m->CurrentQuestion    = NULL;	m->rrcache_size       = rrcachesize;	m->rrcache_free = &rrcachestorage[0];	for (i=0; i<rrcachesize; i++) rrcachestorage[i].next = &rrcachestorage[i+1];	rrcachestorage[rrcachesize-1].next = NULL;	m->rrcache = NULL;	m->ip                 = zeroIPAddr;	m->hostlabel.c[0]     = 0;	m->nicelabel.c[0]     = 0;	m->ResourceRecords    = NULL;	m->SuppressSending    = 0;	m->NetChanged         = false;	m->RR_A1              = zeroRR;	m->RR_A2              = zeroRR;	m->RR_PTR             = zeroRR;	return(mDNSPlatformInit(m));	}extern void mDNS_Close(mDNS *const m)	{	ResourceRecord **p = &m->ResourceRecords;	m->ActiveQuestions = NULL;		// We won't be answering any more questions!	// Make sure there are nothing but deregistering records remaining in the list	while (*p)		{		// If there's a deregistering record remaining, that's okay		if ((*p)->RecordType == kDNSRecordTypeDeregistering)			p=&(*p)->next;		// If there's a shared record remaining, switch it to deregistering		else if ((*p)->RecordType == kDNSRecordTypeShared)			{			debugf("mDNS_Close: Record type kDNSRecordTypeShared still in ResourceRecords list %#s", (*p)->name.c);			mDNS_Deregister_internal(m, *p);			p=&(*p)->next;			}		// Else, just cut it from the list		else			{			debugf("mDNS_Close: Record type %d still in ResourceRecords list %#s", (*p)->RecordType, (*p)->name.c);			*p = (*p)->next;			}		}	// If any deregistering records remain, send their deregistration announcements before we exit	while (m->ResourceRecords)		{		//debugf("mDNS_Close: Sending deregistration announcements");		sendAnswers(m, mDNSPlatformTimeNow());		}		mDNSPlatformClose(m);	}