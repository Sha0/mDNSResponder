/* * Copyright (c) 2002 Apple Computer, Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * The contents of this file constitute Original Code as defined in and * are subject to the Apple Public Source License Version 1.1 (the                                                               * "License").  You may not use this file except in compliance with the * License.  Please obtain a copy of the License at * http://www.apple.com/publicsource and read it before using this file. * * This Original Code and all software distributed under the License are * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the * License for the specific language governing rights and limitations * under the License. * * @APPLE_LICENSE_HEADER_END@ */#include <stdio.h>#include <stdarg.h>							// For va_list supportenum { false = 0, true = 1 };#include "mDNSsprintf.h"#include "mDNSvsprintf.h"static int strlen(char *s)	{	int i=0;	while (*s++) i++;	return(i);	}static const struct format	{	unsigned 		leftJustify : 1;	unsigned 		forceSign : 1;	unsigned 		zeroPad : 1;	unsigned 		havePrecision : 1;	unsigned 		hSize : 1;	unsigned 		lSize : 1;	unsigned 		LSize : 1;			// Note: Does nothing!	char	 		altForm;	char			sign;	char			exponent;	int				fieldWidth;	int				precision;	} default_format = { 0 };#define BUFLEN			512int mDNS_vsprintf(char *sbuffer, const char *fmt, va_list arg)	{	int c, i=0, j, nwritten = 0;	unsigned long n;	char *s;	char buf[BUFLEN], *digits;	struct format F;	for (c = *fmt; c; c = *++fmt)		{		if (c != '%') goto copy1;		F = default_format;			//  decode flags		for (;;)			{			c = *++fmt;			if      (c == '-')	F.leftJustify = true;			else if (c == '+')	F.forceSign = true;			else if (c == ' ')	F.sign = ' ';			else if (c == '#')	F.altForm++;			else if (c == '0')	F.zeroPad = true;			else break;			}			//  decode field width		if (c == '*')			{			if ((F.fieldWidth = va_arg(arg, int)) < 0)				{				F.leftJustify = true;				F.fieldWidth = -F.fieldWidth;				}			c = *++fmt;			}		else			{			for (; c >= '0' && c <= '9'; c = *++fmt)				F.fieldWidth = (10 * F.fieldWidth) + (c - '0');			}			//  decode precision		if (c == '.')			{			if ((c = *++fmt) == '*')				{ F.precision = va_arg(arg, int); c = *++fmt; }			else for (; c >= '0' && c <= '9'; c = *++fmt)					F.precision = (10 * F.precision) + (c - '0');			if (F.precision >= 0) F.havePrecision = true;			}			//  perform appropriate conversion		s = &buf[BUFLEN];		if (F.leftJustify) F.zeroPad = false;conv:	switch (c)			{			case 'h' :	F.hSize = true; c = *++fmt; goto conv;			case 'l' :	F.lSize = true; c = *++fmt; goto conv;			case 'L' :	F.LSize = true; c = *++fmt; goto conv;			// Note: Does nothing!			case 'd' :			case 'i' :	if (F.lSize) n = va_arg(arg, long);						else n = va_arg(arg, int);						if (F.hSize) n = (short) n;						if ((long) n < 0) { n = -n; F.sign = '-'; }						else if (F.forceSign) F.sign = '+';						goto decimal;			case 'u' :	if (F.lSize) n = va_arg(arg, unsigned long);						else n = va_arg(arg, unsigned int);						if (F.hSize) n = (unsigned short) n;						F.sign = 0;						goto decimal;			decimal:	if (!F.havePrecision)							{							if (F.zeroPad)								{								F.precision = F.fieldWidth;								if (F.sign) --F.precision;								}							if (F.precision < 1) F.precision = 1;							}						for (i = 0; n; n /= 10, i++) *--s = n % 10 + '0';						for (; i < F.precision; i++) *--s = '0';						if (F.sign) { *--s = F.sign; i++; }						break;			case 'o' :	if (F.lSize) n = va_arg(arg, unsigned long);						else n = va_arg(arg, unsigned int);						if (F.hSize) n = (unsigned short) n;						if (!F.havePrecision)							{							if (F.zeroPad) F.precision = F.fieldWidth;							if (F.precision < 1) F.precision = 1;							}						for (i = 0; n; n /= 8, i++) *--s = n % 8 + '0';						if (F.altForm && i && *s != '0') { *--s = '0'; i++; }						for (; i < F.precision; i++) *--s = '0';						break;			case 'a' :	{						unsigned char *a = va_arg(arg, unsigned char *);						unsigned short *w = (unsigned short *)a;						s = buf;						switch (F.precision)							{							case  4: i = mDNS_sprintf(s, "%d.%d.%d.%d", a[0], a[1], a[2], a[3]); break;							case  6: i = mDNS_sprintf(s, "%02X:%02X:%02X:%02X:%02X:%02X", a[0], a[1], a[2], a[3], a[4], a[5]); break;							case 16: i = mDNS_sprintf(s, "%04X:%04X:%04X:%04X:%04X:%04X:%04X:%04X",												w[0], w[1], w[2], w[3], w[4], w[5], w[6], w[7]); break;							default: i = mDNS_sprintf(s, "%s", "ERROR: Must specify address size "												"(i.e. %.4a=IPv4, %.6a=Ethernet, %.16a=IPv6) >>"); break;							}						}						break;			case 'p' :	F.havePrecision = F.lSize = true;						F.precision = 8;			case 'X' :	digits = "0123456789ABCDEF";						goto hexadecimal;			case 'x' :	digits = "0123456789abcdef";			hexadecimal:if (F.lSize) n = va_arg(arg, unsigned long);						else n = va_arg(arg, unsigned int);						if (F.hSize) n = (unsigned short) n;						if (!F.havePrecision)							{							if (F.zeroPad)								{								F.precision = F.fieldWidth;								if (F.altForm) F.precision -= 2;								}							if (F.precision < 1) F.precision = 1;							}						for (i = 0; n; n /= 16, i++) *--s = digits[n % 16];						for (; i < F.precision; i++) *--s = '0';						if (F.altForm) { *--s = c; *--s = '0'; i += 2; }						break;			case 'c' :	*--s = va_arg(arg, int); i = 1; break;			case 's' :	s = va_arg(arg, char *);						switch (F.altForm)							{							case 0: i = strlen(s); break;				// C string							case 1: i = (unsigned char) *s++; break;	// Pascal string							case 2: {									// DNS label-sequence name									unsigned char *a = (unsigned char *)s;									s = buf;									if (*a == 0) *s++ = '.';	// Special case for root DNS name									while (*a && s + *a + 1 < &buf[BUFLEN])										{										s += mDNS_sprintf(s, "%#s.", a);										a += 1 + *a;										}									i = s - buf;									s = buf;									break;									}							}						if (F.havePrecision && i > F.precision) i = F.precision;						break;			case 'n' :	s = va_arg(arg, char *);						if      (F.hSize) * (short *) s = nwritten;						else if (F.lSize) * (long  *) s = nwritten;						else              * (int   *) s = nwritten;						continue;				//  oops - unknown conversion, abort			case 'M': case 'N': case 'O': case 'P': case 'Q':			case 'R': case 'S': case 'T': case 'U': case 'V':			// (extra cases force this to be an indexed switch)			default: goto done;			case '%' :			copy1    :	*sbuffer++ = c; ++nwritten; continue;			}			//  pad on the left		if (i < F.fieldWidth && !F.leftJustify)			do { *sbuffer++ = ' '; ++nwritten; } while (i < --F.fieldWidth);			//  write the converted result		for (j=0; j<i; j++) *sbuffer++ = *s++;		nwritten += i;			//  pad on the right		for (; i < F.fieldWidth; i++)			{ *sbuffer++ = ' '; ++nwritten; }		}done: return(nwritten);	}int mDNS_sprintf(char *sbuffer, const char *fmt, ...){	int	length;	    va_list ptr;	va_start(ptr,fmt);	length = mDNS_vsprintf(sbuffer, fmt, ptr);	sbuffer[length] = 0;	va_end(ptr);		return length;}