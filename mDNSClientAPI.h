/* * Copyright (c) 2002 Apple Computer, Inc. All rights reserved. * * @APPLE_LICENSE_HEADER_START@ * * The contents of this file constitute Original Code as defined in and * are subject to the Apple Public Source License Version 1.1 (the * "License").  You may not use this file except in compliance with the * License.  Please obtain a copy of the License at * http://www.apple.com/publicsource and read it before using this file. * * This Original Code and all software distributed under the License are * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES, * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the * License for the specific language governing rights and limitations * under the License. * * @APPLE_LICENSE_HEADER_END@ */#include "mDNSDebug.h"#ifdef	__cplusplus	extern "C" {#endif// ***************************************************************************// DNS Resource Record class and type constantstypedef enum			// From RFC 1035	{	kDNSClass_IN = 1,	// Internet	kDNSClass_CS,		// CSNET	kDNSClass_CH,		// CHAOS	kDNSClass_HS,		// Hesiod	kDNSQClass_ANY = 255// Not a DNS class, but a DNS query class, meaning "all classes"	} DNS_ClassValues;typedef enum			// From RFC 1035	{	kDNSType_A = 1,		//  1 Address	kDNSType_NS,		//  2 Name Server	kDNSType_MD,		//  3 Mail Destination	kDNSType_MF,		//  4 Mail Forwarder	kDNSType_CNAME,		//  5 Canonical Name	kDNSType_SOA,		//  6 Start of Authority	kDNSType_MB,		//  7 Mailbox	kDNSType_MG,		//  8 Mail Group	kDNSType_MR,		//  9 Mail Rename	kDNSType_NULL,		// 10 NULL RR	kDNSType_WKS,		// 11 Well-known-service	kDNSType_PTR,		// 12 Domain name pointer	kDNSType_HINFO,		// 13 Host information	kDNSType_MINFO,		// 14 Mailbox information	kDNSType_MX,		// 15 Mail Exchanger	kDNSType_TXT,		// 16 Arbitrary text string		kDNSType_SRV = 33,	// 33 Service record	kDNSQType_ANY = 255	// Not a DNS type, but a DNS query type, meaning "all types"	} DNS_TypeValues;// ***************************************************************************// Simple typesenum	{	mStatus_AlreadyRegistered = -2,	mStatus_NoCache = -1,	mStatus_NoError = 0,	mStatus_Waiting = 1	};typedef SInt32 mStatus;// ***************************************************************************// Program data structures#define MAX_DOMAIN_LABEL 63#define MAX_DOMAIN_NAME 255// Shared Resource Records do not have to be unique// -- Shared Resource Records are used for NIAS service PTRs// -- It is okay for several hosts to have RRs with the same name but different RDATA// -- We use a random delay on replies to reduce collisions when all the hosts reply to the same query// -- These RRs typically have moderately high TTLs (e.g. one hour)// -- These records are announced on startup and topology changes for the benefit of passive listeners// Unique Resource Records should be unique among hosts within any given mDNS scope// -- The majority of Resource Records are of this type// -- If two entities on the network have RRs with the same name but different RDATA, this is a conflict// -- Replies are sent immediately, because only one host should be replying to any particular query// -- These RRs typically have low TTLs (e.g. ten seconds)// -- On startup and after topology changes, a host issues queries to verify uniqueness// Known Unique Resource Records are treated like Unique Resource Records, except that mDNS does// not have to verify their uniqueness because this is already known by other means (e.g. the RR name// is derived from the host's IP or Ethernet address, which is already known to be a unique identifier).// If another conflicting Resource Record is detected, the Resource Record type is set to kDNSconflict// which prevents this record from being sent in response to further queriesenum	{	kDNSRecordTypeUnregistered     = 0,	// Not currently in active list	kDNSRecordTypeShared           = 1,	// Shared means record name does not have to be unique -- so use random delay on replies	kDNSRecordTypeDeregistering    = 2, // Shared record is about to announce its departure	kDNSRecordTypeUnique           = 3,	// Unique means mDNS should check that name is unique (and then send immediate replies)	kDNSRecordTypeKnownUnique      = 4,	// Known Unique means mDNS can assume name is unique without checking	kDNSRecordTypeConflict         = 5,	// Conflict means don't send answers at all for this record	kDNSRecordTypePacketAnswer     = 6,	// Received in the Answer Section of a DNS Response	kDNSRecordTypePacketAdditional = 7	// Received in the Additional Section of a DNS Response	};enum	{	kDNSSendPriorityNone       = 0,		// Don't need to send this record right now	kDNSSendPriorityAdditional = 1,		// Send this record as an additional, if we have space in the packet	kDNSSendPriorityAnswer     = 2		// Ned to send this record as an answer	};typedef struct { UInt8 c[ 64]; } domainlabel;		// One label: length byte and up to 63 characterstypedef struct { UInt8 c[256]; } UTF8str255;		// Null-terminated C stringtypedef struct { UInt8 c[256]; } domainname;		// Up to 255 bytes of length-prefixed domainlabelstypedef struct { UInt16 priority; UInt16 weight; IPPort port; domainname target; } rdataSRV;typedef union	{	UInt8      data[1];		// Generic untyped data	IPAddr     ip;			// For 'A' record	domainname name;		// For PTR and CNAME records	UTF8str255 txt;			// For TXT record	rdataSRV   srv;			// For SRV record	} RData;typedef struct ResourceRecord_struct ResourceRecord;typedef struct ResourceRecord_struct *ResourceRecordPtr;typedef struct mDNS_struct mDNS;typedef struct mDNS_PlatformSupport_struct mDNS_PlatformSupport;typedef void mDNSCollisionCallback(const mDNS *const m, const ResourceRecord *const rr);struct ResourceRecord_struct	{	ResourceRecord        *next;	ResourceRecord        *additional;	// Recommended additional record to include in response	mDNSCollisionCallback *collision;	UInt8      RecordType;				// See enum above	UInt8      PacketCount;	UInt8      SendPriority;			// 0 no send, 1 send in additional, 2 send in answer	UInt8      padding1;	SInt32     NextSendTime;			// In platform time units (Only for our own records)	SInt32     NextSendInterval;		// In platform time units (Only for our own records).										// NextSendInterval will be non-zero for an active question;										// Zero for a cancelled or inactive question	SInt32     TimeRcvd;				// In platform time units (Only for cache records)	SInt32     LastUsed;				// In platform time units (Only for cache records)	IPAddr     interface;				// Set if this RR is specific to one interface (e.g. a linklocal address)	domainname name;	UInt16     rrtype;	UInt16     rrclass;	UInt32     rroriginalttl;			// In seconds.	UInt32     rrremainingttl;			// In seconds. Always set to correct value before calling question callback.	UInt32     rdlength;	RData      rdata;	};typedef struct DNSQuestion_struct DNSQuestion;typedef void mDNSAnswerCallback(mDNS *const m, DNSQuestion *question, const ResourceRecord *const answer, void *context);struct DNSQuestion_struct	{	DNSQuestion        *next;	SInt32              NextSendTime;		// In platform time units	SInt32              NextSendInterval;	// In platform time units (zero for questions not in list)	IPAddr              interface;			// Non-zero if you want to issue link-local queries only on a single specific IP interface	domainname          name;	UInt16              rrtype;	UInt16              rrclass;	mDNSAnswerCallback *callback;	void               *context;	};typedef struct	{	ResourceRecord RR_A;	// IP Address for this service	ResourceRecord RR_SRV;	// e.g. name._printer._tcp.local.arpa. SRV 0 0 port target	ResourceRecord RR_TXT;	// e.g. name._printer._tcp.local.arpa. TXT PrintQueueName	ResourceRecord RR_ALL;	// e.g. _all.local.arpa.           PTR <srv name> %%% Delete	ResourceRecord RR_LINK;	// e.g. _printer._tcp.local.arpa.      PTR <srv name>	ResourceRecord RR_HOST;	// e.g. _printer._tcp.host.local.arpa. PTR <srv name> %%% Delete	} ServiceRecordSet;typedef struct	{	domainname name;	IPAddr     interface;	// Local (source) IP Interface (needed for scoped addresses such as link-local)	IPAddr     ip;			// Remote (destination) IP address where this service can be accessed	IPPort     port;		// Port where this service can be accessed	UInt8      got_ip;	UInt8      got_txt;	UTF8str255 txtinfo;		// Additional demultiplexing information (e.g. LPR queue name)	} ServiceInfo;typedef struct ServiceInfoQuery_struct ServiceInfoQuery;typedef void ServiceInfoQueryCallback(mDNS *const m, ServiceInfoQuery *query, void *context);struct ServiceInfoQuery_struct	{	DNSQuestion               qSRV;	DNSQuestion               qTXT;	DNSQuestion               qADD;	ServiceInfo              *info;	ServiceInfoQueryCallback *callback;	void                     *context;	};// ***************************************************************************// The main mDNS object, used to hold all the mDNS statetypedef void mDNSCallback(const mDNS *const m);struct mDNS_struct	{	mDNS_PlatformSupport *p;		// Pointer to platform-specific data of indeterminite size	mStatus mDNSPlatformStatus;	mDNSCallback *initComplete;	UInt32 mDNS_busy;				// For debugging: To catch and report locking failures	UInt8 lock_rrcache;				// For debugging: Set at times when these lists may not be modified	UInt8 lock_Questions;	UInt8 lock_Records;	UInt8 padding;	// These fields only required for mDNS Searcher...	DNSQuestion *ActiveQuestions;	// List of all active questions	DNSQuestion *NewQuestions;		// Fresh Question not yet answered from cache	DNSQuestion *CurrentQuestion;	// Next question about to be examined in AnswerLocalQuestions()	UInt32 rrcache_size;	ResourceRecord *rrcache_free;	ResourceRecord *rrcache;	// Fields below only required for mDNS Responder...	IPAddr ip;	domainlabel hostlabel;			// Conforms to RFC 1034 "letter-digit-hyphen" ARPANET host name rules	domainlabel nicelabel;			// Rich text label encoded using canonically precomposed UTF-8	ResourceRecord *ResourceRecords;	SInt32 SuppressSending;	Boolean NetChanged;	// Standard ResourceRecords that every Responder host should have	ResourceRecord RR_A1;			// 'A' (address) record for our ".local" name	ResourceRecord RR_A2;			// 'A' record for our ".local.arpa" name	ResourceRecord RR_PTR;			// PTR (reverse lookup) record	};// ***************************************************************************// Main Client Functions// Every client should call mDNS_Init, passing in storage for the mDNS object, mDNS_PlatformSupport object, and rrcache.// The rrcachesize parameter is the size of (i.e. number of entries in) the rrcache array passed in.// When mDNS has finished setting up the initComplete callback is called// A client can also spin and poll the mDNSPlatformStatus field to see when it changes from mStatus_Waiting to mStatus_NoError//// Call mDNS_Close to tidy up before exiting//// Call mDNS_Register with a completed ResourceRecord object to register a resource record// If the resource record type is kDNSRecordTypeUnique (or kDNSknownunique) then if a conflicting resource record is discovered,// the resource record's mDNSCollisionCallback will be called. The callback should deregister the record, and may// then try registering the record again after picking a new name (e.g. by automatically appending a number)//// Call mDNS_StartQuery to initiate a query. mDNS will proceed to issue Multicast DNS query packets, and any time a reply// is received containing a record which matches the question, the DNSQuestion's mDNSAnswerCallback function will be called// Call mDNS_StopQuery when no more answers are required//// The mDNS routines are intentionally not thread-safe -- adding locking operations would add overhead that may not// be necessary or appropriate on every platform. Instead, code in a pre-emptive environment calling any mDNS routine// (except mDNS_Init and mDNS_Close) is responsible for doing the necessary synchronization to ensure that mDNS code is// not re-entered. This includes both client software above mDNS, and the platform support code below. For example, if// the support code on a particular platform implements timer callbacks at interrupt time, then clients on that platform// need to disable interrupts or do similar concurrency control to ensure that the mDNS code is not entered by an// interrupt-time timer callback while in the middle of processing a client call.extern mStatus mDNS_Init      (mDNS *const m, mDNS_PlatformSupport *const p,								ResourceRecord *const rrcachestorage, const UInt32 rrcachesize, mDNSCallback *const initComplete);extern void    mDNS_Close     (mDNS *const m);extern mStatus mDNS_Register  (mDNS *const m, ResourceRecord *const rr, UInt8 RecordType);extern void    mDNS_Deregister(mDNS *const m, ResourceRecord *const rr);extern mStatus mDNS_StartQuery(mDNS *const m, DNSQuestion *const question);extern void    mDNS_StopQuery (mDNS *const m, DNSQuestion *const question);// ***************************************************************************// General utility and helper functions// mDNS_RegisterHost is a single call to register the standard resource records associated with every host.// mDNS_RegisterService is a single call to register the set of resource records associated with a given named service.//// mDNS_StartResolveService is single call which is equivalent to multiple calls to mDNS_StartQuery,// to find the IP address, port number, and demultiplexing information for a given named service.// As with mDNS_StartQuery, it executes asynchronously, and calls the ServiceInfoQueryCallback when the answer is// found. After the service is resolved, the client should call mDNS_StopResolveService to complete the transaction.// The client can also call mDNS_StopResolveService at any time to abort the transaction.//// mDNS_GetBrowseDomains is a special case of the mDNS_StartQuery call, where the resulting answers// are a list of PTR records indicating (in the rdata) domains that are recommended for browsing.// After getting the list of domains to browse, call mDNS_StopQuery to end the search.// mDNS_GetDefaultBrowseDomain returns the name of the domain that should be highlighted by default.//// mDNS_GetRegistrationDomains and mDNS_GetDefaultRegistrationDomain are the equivalent calls to get the list// of one or more domains that should be offered to the user as choices for where they may register their service,// and the default domain in which to register in the case where the user has made no selection.extern int     mDNS_sprintf(char *sbuffer, const char *fmt, ...);extern void    mDNS_SetupResourceRecord(ResourceRecord *rr, ResourceRecord *additional,               IPAddr interface, UInt16 rrtype, UInt32 ttl);extern mStatus mDNS_RegisterHost     (mDNS *m);extern void    mDNS_DeregisterHost   (mDNS *m);extern mStatus mDNS_RegisterService  (mDNS *m, ServiceRecordSet *sr, IPPort port, const char txtinfo[],               const domainlabel *const name, const domainname *const type, const domainname *const domain);extern void    mDNS_DeregisterService(mDNS *m, ServiceRecordSet *sr);extern mStatus mDNS_StartBrowse(mDNS *m, DNSQuestion *const question,				const char *const srv, const char *const domain, const IPAddr interface, mDNSAnswerCallback *callback, void *context);#define        mDNS_StopBrowse mDNS_StopQueryextern mStatus mDNS_StartResolveService(mDNS *m, ServiceInfoQuery *query, ServiceInfo *info, ServiceInfoQueryCallback *callback, void *context);extern void    mDNS_StopResolveService (mDNS *m, ServiceInfoQuery *query);extern mStatus mDNS_GetBrowseDomains            (mDNS *m, const DNSQuestion *const q);extern mStatus mDNS_GetDefaultBrowseDomain      (mDNS *m, domainname *const d);extern mStatus mDNS_GetRegistrationDomains      (mDNS *m, const DNSQuestion *const q);extern mStatus mDNS_GetDefaultRegistrationDomain(mDNS *m, domainname *const d);// ***************************************************************************// Utility functions for manipulating DNS labels and DNS names// In order to expose the full capabilities of the DNS protocol (which allows any arbitrary eight-bit values// in domain name labels, including unlikely characters like ascii nulls and even dots) all the mDNS APIs// work with DNS's native length-prefixed strings. For convenience in C, the following utility functions// are provided for converting between C's null-terminated strings and DNS's length-prefixed strings.extern Boolean sameDomainName(const domainname *const d1, const domainname *const d2);extern UInt32 DomainNameLength(const domainname *const name);extern void AppendDomainLabelToName(domainname *const name, const domainlabel *const label);extern void AppendStringLabelToName(domainname *const name, const char *const cstr);extern void AppendStringNameToName(domainname *const name, const char *cstr);extern void   ConvertCStringToDomainLabel(const char *src, domainlabel *label);extern UInt8 *ConvertCStringToDomainName(const char *const cstr, domainname *name);extern char *ConvertDomainLabelToCString_withescape(const domainlabel *const name, char *cstr, UInt8 esc);#define      ConvertDomainLabelToCString_unescaped(D,C) ConvertDomainLabelToCString_withescape((D), (C), 0)#define      ConvertDomainLabelToCString(D,C)           ConvertDomainLabelToCString_withescape((D), (C), '\\')extern char *ConvertDomainNameToCString_withescape(const domainname *const name, char *cstr, UInt8 esc);#define      ConvertDomainNameToCString_unescaped(D,C) ConvertDomainNameToCString_withescape((D), (C), 0)#define      ConvertDomainNameToCString(D,C)           ConvertDomainNameToCString_withescape((D), (C), '\\')extern UInt8    *ConstructServiceName(domainname *fqdn, const domainlabel *name, const domainname *type, const domainname *domain);extern Boolean DeconstructServiceName(const domainname *fqdn, domainlabel *name, domainname *type, domainname *domain);#ifdef	__cplusplus	}#endif